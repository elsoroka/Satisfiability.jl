var documenterSearchIndex = {"docs":
[{"location":"example_job_shop/#Job-shop-scheduling","page":"Job shop scheduling","title":"Job shop scheduling","text":"","category":"section"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"The job shop scheduling problem is a linear integer problem arising in operations research.","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"Suppose you are managing a machine shop with several different jobs in progress. Each job consists of a series of tasks. Some of the tasks have ordering constraints: e.g. parts must be manufactured before they can be installed in a larger assembly. Due to equipment constraints, we cannot schedule two tasks requiring the same machine at the same time. Additionally, all tasks must have a worker assigned to complete them.","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"In this problem (from Microsoft's Z3 tutorial) we have three jobs, each consisting of one task to be completed first by worker A and one to be completed second by worker B. Each task has an integer-valued duration. Workers cannot work on two tasks at once or take each others' tasks.","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"We'd like to find a solution such that all three jobs can be completed in an 8-hour workday.","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"Define two vector-valued variables t1 and t2 such that tj[i] is the start time of job i for worker j.\nDefine two vector-valued variables d1 and d2 such that dj[i] is the duration of job i for worker j.","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"using BooleanSatisfiability\nn = 3 # number of jobs\nm = 2 # number of tasks per job\n@satvariable(t1[1:n], :Int)\n@satvariable(t2[1:n], :Int)\nd1 = [2; 3; 2]\nd2 = [1; 1; 3]","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"A start time of 0 corresponds to the first hour of the workday, and an end time of 8 corresponds to the last hour of the workday.","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"working_hours = all(and.(t1 .>= 0, t2 .+ d2 .<= 8))","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"Sequencing constraint: For each job, A must complete the first task before B can start the second task","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"sequencing = and(t2 .>= t1 .+ d1)","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"Overlap constraint between all permutations","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"overlaps = [(1,2), (1,3), (2,3)]\noverlap_1 = all([or( t1[i] >= t1[j] + d1[j], t1[j] >= t1[i] + d1[i]) for (i,j) in overlaps])\noverlap_2 = all([or( t2[i] >= t2[j] + d2[j], t2[j] >= t2[i] + d2[i]) for (i,j) in overlaps])","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"Solve the problem","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"status = sat!(working_hours, sequencing, overlap_1, overlap_2, solver=Z3())\nprintln(\"status = $status\")\nif status == :SAT\n    println(\"t1 = $(value(t1))\")\n    println(\"t2 = $(value(t2))\")\nend","category":"page"},{"location":"example_scheduling/#Finding-a-meeting-time","page":"Finding a meeting time","title":"Finding a meeting time","text":"","category":"section"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"We have n people's availabilities for the meeting times 9a, 10a, 11a, 12, 1p, 2p, 3p, 4p. Each person's availability is reprsented as a Boolean vector a^topin 01^8. We would like to schedule J meetings between different groups of people, represented by J index sets mathcalI_jsubseteq1dotsn.","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"Rules:","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"Each meeting mathcalI_j must occur at one time t.\nAll people attending meeting mathcalI_j must be available at time t.\nAll people attending meeting mathcalI_j must not be attending another meeting at time t.\nNo attendee should have >2 hours of consecutive meetings.","category":"page"},{"location":"example_scheduling/#Setup","page":"Finding a meeting time","title":"Setup","text":"","category":"section"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"We concatenate the availability row vectors into a 5 x 8 Boolean matrix bar A.","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"using BooleanSatisfiability\n\nn = 5 # number of people\nT = 8 # number of times\n\n# nxT matrix: each row is one attendee's meeting availability\nA_bar = Bool[\n    1 0 1 0 1 1 1 1\n    0 1 1 0 0 0 0 1\n    1 1 1 0 1 1 0 1\n    1 1 0 1 1 0 0 0\n    0 1 1 1 0 0 0 1\n]\n\n# A is a matrix-valued variable such that ``A_{it} = 1`` if attendee ``i`` is in a meeting at time ``t`` and 0 otherwise.\n@satvariable(A[1:n, 1:T], :Bool)\n","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"The index_sets represent which meeting attendees are required at each meeting mathcalI_j.","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"index_sets = [[1,2,3], [3,4,5], [1,3,5], [1,4]]\nJ = length(index_sets) # number of meetings","category":"page"},{"location":"example_scheduling/#Logical-constraints","page":"Finding a meeting time","title":"Logical constraints","text":"","category":"section"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"If attendee i is unavailable at time t (bar A_it = 0) then they cannot be in a meeting at time t.","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"unavailability = and(¬A_bar .⟹ ¬A)","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"For each meeting j, all attendees in index set mathcalI_j must be available at some time t and not attending another meeting.","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"M = [and(A[index_sets[j], t]) for j=1:J, t=1:T]\n\n# get a list of conflicts\nconflicts = [filter((i) -> i != j && length(intersect(index_sets[j], index_sets[i])) > 0, 1:J) for j=1:J ]\nno_double_booking = all([M[j,t] ⟹ ¬or(M[conflicts[j],t]) for j=1:J, t=1:T])","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"All meetings must be scheduled.","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"require_one_time = all([or(M[j,:]) for j=1:J])","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"No attendee should have more than 2 consecutive hours of meetings.","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"time_limit = all([¬and(A[i,t:t+2]) for i=1:n, t=1:T-2])","category":"page"},{"location":"example_scheduling/#Solving-the-problem","page":"Finding a meeting time","title":"Solving the problem","text":"","category":"section"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"# solve\nexprs = [no_double_booking, require_one_time, unavailability, time_limit]\nstatus = sat!(exprs, Z3())\n\nprintln(\"status = $status\") # for this example we know it's SAT\ntimes = [\"9a\", \"10a\", \"11a\", \"12p\", \"1p\", \"2p\", \"3p\", \"4p\"]\nfor j=1:J\n    println(\"Meeting with attendees $(index_sets[j]) can occur at $(times[findall(value(M[j,:]) .== true)])\")\nend\n\nprintln(\"Value A: $(value(A))\")\nprintln(\"Value N: $(value(M))\")","category":"page"},{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Pages = [\"functions.md\"]\nDepth = 3","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Test link link","category":"page"},{"location":"functions/#Defining-variables","page":"Functions","title":"Defining variables","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"The preferred way to define a variable is","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"@satvariable","category":"page"},{"location":"functions/#BooleanSatisfiability.@satvariable","page":"Functions","title":"BooleanSatisfiability.@satvariable","text":"@satvariable(z, :Bool)\n@satvariable(a[1:n], :Int)\n\nConstruct a SAT variable with name z, optional array dimensions, and specified type (:Bool, :Int or :Real).\n\nOne and two-dimensional variables can be constructed with the following syntax.\n\n@satvariable(a[1:n], :Int) # an Int vector of length n\n@satvariable(x[1:m, 1:n], :Real) # an m x n Int matrix\n\n\n\n\n\n","category":"macro"},{"location":"functions/","page":"Functions","title":"Functions","text":"This alternate syntax is also available.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Bool(name::String)\nInt(name::String)\nReal(name::String)","category":"page"},{"location":"functions/#Core.Bool-Tuple{String}","page":"Functions","title":"Core.Bool","text":"Bool(\"z\")\n\nConstruct a single Boolean variable with name \"z\".\n\n    Bool(n, \"z\")\n    Bool(m, n, \"z\")\n\nConstruct a vector-valued or matrix-valued Boolean variable with name \"z\".\n\nVector and matrix-valued Booleans use Julia's built-in array functionality: calling Bool(n,\"z\") returns a Vector{BoolExpr}, while calling Bool(m, n, \"z\") returns a Matrix{BoolExpr}.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Core.Int-Tuple{String}","page":"Functions","title":"Core.Int","text":"Int(\"a\")\n\nConstruct a single Int variable with name \"a\".\n\n    Int(n, \"a\")\n    Int(m, n, \"a\")\n\nConstruct a vector-valued or matrix-valued Int variable with name \"a\".\n\nVector and matrix-valued Ints use Julia's built-in array functionality: calling Int(n,\"a\") returns a Vector{IntExpr}, while calling Int(m, n, \"a\") returns a Matrix{IntExpr}.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Core.Real-Tuple{String}","page":"Functions","title":"Core.Real","text":"Real(\"r\")\n\nConstruct a single Int variable with name \"r\".\n\n    Real(n, \"r\")\n    Real(m, n, \"r\")\n\nConstruct a vector-valued or matrix-valued Real variable with name \"r\".\n\nVector and matrix-valued Reals use Julia's built-in array functionality: calling Real(n,\"a\") returns a Vector{RealExpr}, while calling Real(m, n, \"r\") returns a Matrix{RealExpr}.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Logical-operations","page":"Functions","title":"Logical operations","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"These are operations in the theory of propositional logic. For a formal definition of this theory, see Figure 3.2 in The SMT-LIB Standard, Version 2.6.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"not(z::BoolExpr)\nand(z1::BoolExpr, z2::BoolExpr)\nor(z1::BoolExpr, z2::BoolExpr)\nxor(zs_mixed::Array{T}; broadcast_type=:Elementwise) where T\n\nimplies(z1::BoolExpr, z2::BoolExpr)\niff(z1::BoolExpr, z2::BoolExpr)\nite(x::Union{BoolExpr, Bool}, y::Union{BoolExpr, Bool}, z::Union{BoolExpr, Bool})\n\nall(zs::Array{T}) where T <: BoolExpr\nany(zs::Array{T}) where T <: BoolExpr","category":"page"},{"location":"functions/#BooleanSatisfiability.not-Tuple{BoolExpr}","page":"Functions","title":"BooleanSatisfiability.not","text":"not(z::BoolExpr)\n¬z\n\nReturn the logical negation of z.\n\nNote: Broacasting a unary operator requires the syntax .¬z which can be confusing to new Julia users. We define ¬(z::Array{BoolExpr}) for convenience.\n\n    @satvariable(z[1:n], :Bool)\n    ¬z  # syntactic sugar for map(¬, z)\n    .¬z # also valid\n\n\n\n\n\n","category":"method"},{"location":"functions/#BooleanSatisfiability.and-Tuple{BoolExpr, BoolExpr}","page":"Functions","title":"BooleanSatisfiability.and","text":"z1 ∧ z2\nand(z1,...,zn)\nand([z1,...,zn])\n\nReturns the logical AND of two or more variables. Use dot broadcasting for vector-valued and matrix-valued Boolean expressions.\n\n@satvariable(z1[1:n], :Bool)\n@satvariable(z2[n, 1:m], :Bool)\nz1 .∧ z2\nand.(z1, z2) # equivalent to z1 .∧ z2\n\nSpecial cases:\n\nand(z) returns z.\nand(z, false) returns false.\nand(z, true) returns z.\n\n\n\n\n\n","category":"method"},{"location":"functions/#BooleanSatisfiability.or-Tuple{BoolExpr, BoolExpr}","page":"Functions","title":"BooleanSatisfiability.or","text":"z1 ∨ z2\nor(z1,...,zn)\nor([z1,...,zn])\n\nReturns the logical OR of two or more variables. Use dot broadcasting for vector-valued and matrix-valued Boolean expressions.\n\n@satvariable(z1[1:n], :Bool)\n@satvariable(z2[1:m, 1:n], :Bool)\nz1 .∨ z2\nor.(z1, z2) # equivalent to z1 .∨ z2\n\nSpecial cases:\n\nor(z) returns z.\nor(z, false) returns z.\nor(z, true) returns true.\n\nNote that ∨ (\\vee) is NOT the ASCII character v.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.xor-Union{Tuple{Array{T}}, Tuple{T}} where T","page":"Functions","title":"Base.xor","text":"xor(z1,...,zn)\n⊻(z1,...zn)\n\nXOR (exclusive or) is true if exactly one of z1,...,zn is true and false otherwise. Use dot broadcasting across arrays.\n\nSpecial cases:\n\nxor(z) returns z.\nxor(false, z) returns z.\nxor(true, z) returns ¬z.\nxor(true, true, z) returns false.\n\n\n\n\n\n","category":"method"},{"location":"functions/#BooleanSatisfiability.implies-Tuple{BoolExpr, BoolExpr}","page":"Functions","title":"BooleanSatisfiability.implies","text":"z1 ⟹ z2\nimplies(z1, z2)\n\nReturns the expression z1 IMPLIES z2. Use dot broadcasting for vector-valued and matrix-valued Boolean expressions. Note: implies(z1, z2) is equivalent to or(not(z1), z2).\n\n\n\n\n\n","category":"method"},{"location":"functions/#BooleanSatisfiability.iff-Tuple{BoolExpr, BoolExpr}","page":"Functions","title":"BooleanSatisfiability.iff","text":"iff(z1::BoolExpr, z2::BoolExpr)\nz1 ⟺ z2\n\nBidirectional implication between z1 and z2. Equivalent to and(z1 ⟹ z2, z2 ⟹ z1).\n\n\n\n\n\n","category":"method"},{"location":"functions/#BooleanSatisfiability.ite-Tuple{Union{Bool, BoolExpr}, Union{Bool, BoolExpr}, Union{Bool, BoolExpr}}","page":"Functions","title":"BooleanSatisfiability.ite","text":"ite(x::BoolExpr, y::BoolExpr, z::BoolExpr)\n\nIf-then-else statement. Equivalent to or(x ∧ y, ¬x ∧ z).\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.all-Union{Tuple{Array{T}}, Tuple{T}} where T<:BoolExpr","page":"Functions","title":"Base.all","text":"all([z1,...,zn])\n\nReturn and(z1,...,zn). If z1,...,zn are themselves AND operations, all(z)flattens the nestedAND`.\n\nExamples:\n\nand([and(z1, z2), and(z3, z4)]) == and(z1, z2, z3, z4)\nand([or(z1, z3), z3, z4]) == and(or(z1, z3), z3, z4)\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.any-Union{Tuple{Array{T}}, Tuple{T}} where T<:BoolExpr","page":"Functions","title":"Base.any","text":"any([z1,...,zn])\n\nReturn or(z1,...,zn). If z1,...,zn are themselves OR operations, any(z)flattens the nestedOR`. Examples:\n\nany([or(z1, z2), or(z3, z4)]) == or(z1, z2, z3, z4)\nany([and(z1, z3), z3, z4]) == or(and(z1, z3), z3, z4)\n\n\n\n\n\n","category":"method"},{"location":"functions/#Arithmetic-operations","page":"Functions","title":"Arithmetic operations","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"These are operations in the theory of integer and real-valued arithmetic.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Note that +, -, and * follow type promotion rules: if both a and b are IntExprs, a+b will have type IntExpr. If either a or b is a RealExpr, the result will have type RealExpr. Division \\ is defined only in the theory of real-valued arithmetic, thus it always has return type RealExpr. For a formal definition of the theory of integer arithmetic, see Figure 3.3 in The SMT-LIB Standard, Version 2.6.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Base.:-(a::IntExpr)\nBase.:+(a::IntExpr, b::IntExpr)\nBase.:-(a::IntExpr, b::IntExpr)\nBase.:*(a::RealExpr, b::RealExpr)\nBase.:/(a::RealExpr, b::RealExpr)","category":"page"},{"location":"functions/#Base.:--Tuple{IntExpr}","page":"Functions","title":"Base.:-","text":"-(a::IntExpr)\n-(r::RealExpr)\n\nReturn the negative of an Int or Real expression.\n\n@satvariable(a[1:n, 1:m], :Int)\n-a # this also works\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:+-Tuple{IntExpr, IntExpr}","page":"Functions","title":"Base.:+","text":"a + b\na + 1 + true\n\nReturn the Int | Real expression a+b (inherits the type of a+b). Use dot broadcasting for vector-valued and matrix-valued Boolean expressions.\n\n@satvariable(a[1:n], :Int)\n@satvariable(b[1:n, 1:m], :Int)\na .+ b\nprintln(\"typeof a+b: $(typeof(a[1] + b[1]))\")\n\n@satvariable(c, :Real)\nprintln(\"typeof a+c: $(typeof(a[1] + c))\")\n\n@satvariable(z, :Bool)\na .+ z\nprintln(\"typeof a+z: $(typeof(a[1] + z))\")\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:--Tuple{IntExpr, IntExpr}","page":"Functions","title":"Base.:-","text":"a - b\na - 2\n\nReturns the Int | Real expression a-b (inherits the type of a-b). Use dot broadcasting for vector-valued and matrix-valued Boolean expressions.\n\n@satvariable(a[1:n], :Int)\n@satvariable(b[1:n, 1:m], :Int)\na .- b\nprintln(\"typeof a-b: $(typeof(a[1] - b[1]))\")\n\n@satvariable(c, :Real)\nprintln(\"typeof a-c: $(typeof(a[1] - c))\")\n\n@satvariable(z, :Bool)\na .- z\nprintln(\"typeof a-z: $(typeof(a[1] - z))\")\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:*-Tuple{RealExpr, RealExpr}","page":"Functions","title":"Base.:*","text":"a * b\na * 2\n\nReturns the Int | Real multiplication expression a*b (inherits the type of a*b). Use dot broadcasting for vector-valued and matrix-valued Boolean expressions.\n\n@satvariable(a[1:n], :Int)\n@satvariable(b[1:n, 1:m], :Int)\na .* b\nprintln(\"typeof a*b: $(typeof(a[1]*b[1]))\")\n\n@satvariable(c, :Real)\nprintln(\"typeof a*c: $(typeof(a[1]*c))\")\n\n@satvariable(z, :Bool)\na .- z\nprintln(\"typeof a*z: $(typeof(a[1]*z))\")\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:/-Tuple{RealExpr, RealExpr}","page":"Functions","title":"Base.:/","text":"a / b\na / 1.0\n\nReturns the Real division expression a/b. Note: a and b must be Real). Use dot broadcasting for vector-valued and matrix-valued Boolean expressions.\n\n@satvariable(a[1:n], :Real)\n@satvariable(b[1:n, 1:m], :Real)\na ./ b\nprintln(\"typeof a/b: $(typeof(a[1]/b[1]))\")\n\n\n\n\n\n","category":"method"},{"location":"functions/#Comparison-operators","page":"Functions","title":"Comparison operators","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Base.== - Method","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"    a  == b\n    a == 1.0","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Returns the Boolean expression a == b (arithmetic equivalence). Use dot broadcasting for vector-valued and matrix-valued expressions.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"@satvariable(a[1:n], :Int)\n@satvariable(b[1:n, 1:m], :Int)\na .== b","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Note: To test whether two AbstractExprs are eqivalent (in the sense that all properties are equal, not in the shared-memory-location sense of ===), use isequal.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Base.:<(a::AbstractExpr, b::AbstractExpr)\nBase.:<=(a::AbstractExpr, b::AbstractExpr)\nBase.:>(a::AbstractExpr, b::AbstractExpr)\nBase.:>=(a::AbstractExpr, b::AbstractExpr)","category":"page"},{"location":"functions/#Base.:<-Tuple{AbstractExpr, AbstractExpr}","page":"Functions","title":"Base.:<","text":"a < b\na < 0\n\nReturns the Boolean expression a < b. Use dot broadcasting for vector-valued and matrix-valued expressions.\n\n@satvariable(a[1:n], :Int)\n@satvariable(b[1:n, 1:m], :Int)\na .< b\n@satvariable(z, :Bool)\na .< z\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:<=-Tuple{AbstractExpr, AbstractExpr}","page":"Functions","title":"Base.:<=","text":"a <= b\na <= 0\n\nReturns the Boolean expression a <= b. Use dot broadcasting for vector-valued and matrix-valued expressions.\n\n@satvariable(a[1:n], :Int)\n@satvariable(b[1:n, 1:m], :Int)\na .<= b\n@satvariable(z, :Bool)\na .<= z\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:>-Tuple{AbstractExpr, AbstractExpr}","page":"Functions","title":"Base.:>","text":"a > b\na > 0\n\nReturns the Boolean expression a > b. Use dot broadcasting for vector-valued and matrix-valued expressions.\n\n@satvariable(a[1:n], :Int)\n@satvariable(b[1:n, 1:m], :Int)\na .> b\n@satvariable(z, :Bool)\na .> z\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:>=-Tuple{AbstractExpr, AbstractExpr}","page":"Functions","title":"Base.:>=","text":"a >= b\na >= 0\n\nReturns the Boolean expression a >= b. Use dot broadcasting for vector-valued and matrix-valued expressions.\n\n@satvariable(a[1:n], :Int)\n@satvariable(b[1:n, 1:m], :Int)\na .>= b\n@satvariable(z, :Bool)\na .>= z\n\n\n\n\n\n","category":"method"},{"location":"functions/#Generating-the-SMT-representation-of-a-problem","page":"Functions","title":"Generating the SMT representation of a problem","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"smt(zs::Array{T}) where T <: BoolExpr\nsave(prob::BoolExpr; filename=\"out\")","category":"page"},{"location":"functions/#BooleanSatisfiability.smt-Union{Tuple{Array{T}}, Tuple{T}} where T<:BoolExpr","page":"Functions","title":"BooleanSatisfiability.smt","text":"smt(z::AbstractExpr)\nsmt(z1,...,zn)\nsmt([z1,...,zn])\n\nGenerate the SMT representation of z or and(z1,...,zn).\n\nWhen calling smt([z1,...,zn]), the array must have type Array{AbstractExpr}. Note that list comprehensions do not preserve array typing. For example, if z is an array of BoolExpr, [z[i] for i=1:n] will be an array of type Any. To preserve the correct type, use BoolExpr[z[i] for i=1:n].\n\n\n\n\n\n","category":"method"},{"location":"functions/#BooleanSatisfiability.save-Tuple{BoolExpr}","page":"Functions","title":"BooleanSatisfiability.save","text":"save(z::AbstractExpr, filename)\nsave(z::Array{AbstractExpr}, filename=filename)\nsave(z1, z2,..., filename)                  # z1, z2,... are type AbstractExpr\n\nWrite the SMT representation of z or and(z1,...,zn) to filename.smt.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Solving-a-SAT-problem","page":"Functions","title":"Solving a SAT problem","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"sat!(prob::BoolExpr, solver::Solver)\nvalue(zs::Array{T}) where T <: AbstractExpr","category":"page"},{"location":"functions/#BooleanSatisfiability.sat!-Tuple{BoolExpr, Solver}","page":"Functions","title":"BooleanSatisfiability.sat!","text":"solver = Z3()\nsat!(z::BoolExpr, solver)\nsat!(z1, z2,..., solver)\n\nSolve the SAT problem using a Solver. If the problem is satisfiable, update the values of all BoolExprs in prob with their satisfying assignments.\n\nPossible return values are :SAT, :UNSAT, or :ERROR. prob is only modified to add Boolean values if the return value is :SAT.\n\n\n\n\n\n","category":"method"},{"location":"functions/#BooleanSatisfiability.value-Union{Tuple{Array{T}}, Tuple{T}} where T<:AbstractExpr","page":"Functions","title":"BooleanSatisfiability.value","text":"value(z::BoolExpr)\nvalue(z::Array{BoolExpr})\n\nReturns the satisfying assignment of z, or nothing if no satisfying assignment is known. In the array-valued case, returns Array{Bool} or Array{nothing}.\n\nIt's possible to return an array of mixed Bool and nothing. This could occur if some variables in an array do not appear in a problem, because sat!(problem) will not set the values of variables that do not appear in problem.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Custom-interactions-with-solvers:","page":"Functions","title":"Custom interactions with solvers:","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"open_solver(solver::Solver)\nsend_command(pstdin::Pipe, pstdout::Pipe, cmd::String)\nnested_parens_match(solver_output::String)","category":"page"},{"location":"functions/#BooleanSatisfiability.open_solver-Tuple{Solver}","page":"Functions","title":"BooleanSatisfiability.open_solver","text":"proc, pstdin, pstdout, pstderr = open_solver(s::Solver)\n\nOpen a solver in a new process with in, out, and err pipes. Uses Base.process. Check the source code to see the exact implementation.\n\n\n\n\n\n","category":"method"},{"location":"functions/#BooleanSatisfiability.send_command-Tuple{Pipe, Pipe, String}","page":"Functions","title":"BooleanSatisfiability.send_command","text":"send_command(pstdin::Base.Pipe, pstdout::Base.Pipe, cmd::String; is_done=nested_parens_match, timeout=Inf)\n\nOpen a solver in a new process with in, out, and err pipes. Uses Base.process. Check the source code to see the exact implementation.\n\n\n\n\n\n","category":"method"},{"location":"functions/#BooleanSatisfiability.nested_parens_match-Tuple{String}","page":"Functions","title":"BooleanSatisfiability.nested_parens_match","text":"nested_parens_match(output::String)\n\nReturn true if output has > 0 length and an equal number of left ( and right ), which can be 0.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Miscellaneous-functions","page":"Functions","title":"Miscellaneous functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Base.isequal(a::AbstractExpr, b::AbstractExpr)","category":"page"},{"location":"functions/#Base.isequal-Tuple{AbstractExpr, AbstractExpr}","page":"Functions","title":"Base.isequal","text":"Test equality of two AbstractExprs. To construct an equality constraint, use ==.\n\n\n\n\n\n","category":"method"},{"location":"advanced/#Advanced-usage","page":"Advanced usage","title":"Advanced usage","text":"","category":"section"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"Pages = [\"advanced.md\"]\nDepth = 3","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"NOTE: Some of the options described on this page require you to use the SMTLIB2 specification language directly.","category":"page"},{"location":"advanced/#Custom-solver-options-and-using-other-solvers","page":"Advanced usage","title":"Custom solver options and using other solvers","text":"","category":"section"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"To customize solver options or use a different (unsupported) solver, use the syntax","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"solver = Solver(\"My Solver\", `program_name --option1 --option2`)\nsat!(problem, solver) # sat! will use your provided command to invoke the solver","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"The command you provide must launch a solver that accepts SMTLIB2-formatted commands and can respond to (get-model) in SAT mode. (An example of a command that does NOT work is cvc5 --interactive, because cvc5 cannot answer (get-model) without the --produce-models option.)","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"To familiarize yourself with what this means, you may use save to generate a small SMT file for a satisfiable problem, then call a solver from the terminal, paste in the contents of your SMT file, and issue the command (get-model). This is exactly what BooleanSatisfiability.jl does when you call  sat!. Armed with this knowledge, go forth and customize your solver command.","category":"page"},{"location":"advanced/#Custom-interactions-with-solvers","page":"Advanced usage","title":"Custom interactions with solvers","text":"","category":"section"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"BooleanSatisfiability provides an interface to issue SMT2 commands and receive SMT2-formatted solver responses programmatically. This is useful if you wish to build your own decision logic or parser using advanced solver functionality.","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"!!! note SMT2 solver modes. In the SMT2 specification, after entering a problem and issuing the command (check-sat) the solver will be in either sat or unsat mode. The solver mode determines which commands are valid: for example, (get-unsat-core) is only valid in unsat mode and (get-model) is only valid in sat mode. You can find descriptions of modes and listings of valid commands in the latest SMT-LIB Standard.","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"Here's an example.","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"@satvariable(x[1:2], :Bool)\nexpr = (x[1] ∧ ¬x[1]) ∧ any(x) # unsat\n\nsolver = Z3()\nproc, pstdin, pstdout, pstderr = open_process(solver)\n\n# smt() adds the command (check-sat), so Z3 will be in either `sat` or `unsat` mode after this command.\ninput = smt(expr)\nresponse = send_command(pstdin, pstdout, input, is_done=nested_parens_match)\n\nprintln(\"status = $response\") # :UNSAT\n\nresponse = send_command(pstdin, pstdout, \"(get-unsat-core)\", is_done=nested_parens_match)\nprintln(response)\n\n# more interactions via `send_command`...\n\n# it's good form to clean up your process\nclose(proc)","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"When using this functionality, you are responsible for keeping track of the solver mode and parsing the result of send_command.","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"Checking if the response is complete","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"The send_command function has an optional argument is_done for checking whether the full response has been received. The default is nested_parens_match(output::String) which returns true if response contains at least 1 matching pair of parentheses. This ensures the entire output is returned when issuing commands such as (get-model) where the response is wrapped in at least 1 set of parentheses.","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"!!! warning Multiple parenthesized statements If your command produces a response with multiple separate statements, for example (statement_1)\\n(statement_2), nested_parens_match is not guaranteed to return the entire response. The intended use case is ((statement_1)\\n(statement_2)).","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"Customizing is_done","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"A custom function is_done(response::String)::Bool, should have the following behavior:","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"is_done returns true if the given response is valid (in whatever sense you define) and false if not.\nsend_command will WAIT for more output while is_done is false.","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"SAT solvers can be slow and some commands produce long outputs. Without is_done, send_command could receive a partial response and prematurely return.","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"For full implementation details, please see the source code of call_solver.jl.","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Pages = [\"installation.md\"]\nDepth = 3","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"NOTE: To successfully use this package you will need to install a back-end solver. Z3 and CVC5 are currently supported. You may use other solvers at your own risk.","category":"page"},{"location":"installation/#Installing-BooleanSatisfiability","page":"Installation","title":"Installing BooleanSatisfiability","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"You can install the latest version of BooleanSatisfiability with the command using Pkg; Pkg.add(url=\"https://github.com/elsoroka/BooleanSatisfiability.jl/\") (TODO) Add official way when package is published.","category":"page"},{"location":"installation/#Installing-a-Solver","page":"Installation","title":"Installing a Solver","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"BooleanSatisfiability uses Julia's Base.Process library to interact with solvers. Thus to successfully install a solver for this package, all you need to do is make sure the appropriate command (listed below) works in your machine's terminal.","category":"page"},{"location":"installation/#Debian-Linux","page":"Installation","title":"Debian Linux","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install Z3, use sudo apt-get install z3. If you can launch Z3 from the command line by typing z3 -smt2 -in, your installation is correct.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install cvc5:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Download the appropriate binary here and save it as cvc5. (Note: if you already have cvc5 installed under the name cvc5-linux, make a symlink to the name cvc5 or customize your solver command to use the name cvc5-linux.)\nSet the executable permission: chmod +x ./cvc5.\nMost users should move the binary to /usr/local/bin. This allows it to be found from the command line.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you can launch cvc5 from the command line by typing cvc5 --interactive --produce-models, your installation is correct.","category":"page"},{"location":"installation/#OS-X","page":"Installation","title":"OS X","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"(TODO)","category":"page"},{"location":"installation/#Windows","page":"Installation","title":"Windows","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"(TODO)","category":"page"},{"location":"#Solving-SMT-Problems-in-Julia","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"","category":"section"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"BooleanSatisfiability.jl is a package for representing Boolean satisfiability (SAT) and selected other satisfiability modulo theories (SMT) problems in Julia. This package provides a simple front-end interface to common SMT solvers, including full support for vector-valued and matrix-valued expressions.","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"Pages = [\"index.md\"]\nDepth = 4","category":"page"},{"location":"#What-is-a-SAT-problem?","page":"Solving SMT Problems in Julia","title":"What is a SAT problem?","text":"","category":"section"},{"location":"#Boolean-variables-and-literals","page":"Solving SMT Problems in Julia","title":"Boolean variables and literals","text":"","category":"section"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"A Boolean variable can only take on the values true or false (0 or 1).","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"The variable z, which could be either true or false, is a variable, while the value true is a literal. Julia provides built-in support for Boolean literals using the Bool type. This package defines the BoolExpr type to represent Boolean variables.","category":"page"},{"location":"#Logical-formulae","page":"Solving SMT Problems in Julia","title":"Logical formulae","text":"","category":"section"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"We can construct a logical formula using Boolean variables, literals, and operators. This package defines four operators. Both the plaintext and mathematical symbols are available.","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"not(z), or ¬z: the negation of z.\nand(z1, z2) or z1 ∧ z2. The n-ary version, and(z1,...,zn), is also available.\nand(z1, z2) or z1 ∨ z2. The n-ary version, and(z1,...,zn), is also available.\nimplies(z1, z2) or z1 ⟹ z2.","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"These expressions can be nested to produce formulae of arbitrary complexity.","category":"page"},{"location":"#SAT-problems","page":"Solving SMT Problems in Julia","title":"SAT problems","text":"","category":"section"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"Given a Boolean expression, the associated SAT problem can be posed as:","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"\"Is there a satisfying assignment of literals (1's and 0's) such that this formula is true?\"","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"If this assignment exists, we say the formula is satisfiable. More than one satisfying assignment may exist for a given formula.\nIf the assignment does not exist, we say the formula is unsatisfiable.","category":"page"},{"location":"#SMT-problems","page":"Solving SMT Problems in Julia","title":"SMT problems","text":"","category":"section"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"Satisfiability modulo theories is a superset of Boolean satisfiability. SMT encompasses many other theories besides Boolean logic, two of which are supported here.","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"In the theory of integers, we can define integer-valued variables and operations such as +, -, * and the comparisons <, <=, ==, =>, >. For example, we could determine whether there exists a satisfying assignment for integers a and b such that a <= b, b <= 1 and a + b >= 2. (There is - set a = 1 and b = 1.)","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"In the theory of reals, we can define real-valued variables and operations. Reals use the same operations as integers, plus division (\\). However, algorithms to solve SMT problems over real variables are often slow and not guaranteed to find a solution. If you have a problem over only real-valued variables, you should use JuMP and a solver like Gurobi instead.","category":"page"},{"location":"#How-does-BooleanSatisfiability.jl-work?","page":"Solving SMT Problems in Julia","title":"How does BooleanSatisfiability.jl work?","text":"","category":"section"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"BooleanSatisfiability.jl provides an interface to SAT solvers that accept input in the SMTLIB2 format. It works by generating the SMT representation of your problem, then invoking a solver to read said file.","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"Currently, Z3 is supported.","category":"page"},{"location":"faq/#FAQ","page":"FAQ","title":"FAQ","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Pages = [\"faq.md\"]\nDepth = 3","category":"page"},{"location":"faq/#Where-can-I-get-help?","page":"FAQ","title":"Where can I get help?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Please open a Github issue! This is a new package and we would love to hear your suggestions, bug reports, feature requests, and other commentary.","category":"page"},{"location":"faq/#Isn't-this-functionality-included-in-JuMP?","page":"FAQ","title":"Isn't this functionality included in JuMP?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"JuMP provides support for integer and Boolean-valued variables, however it is developed primarily to support mathematical optimization over real-valued or integer-valued variables and continuous functions. As such, JuMP interfaces with solvers such as ECOS, MOSEK, and Gurobi that are intended for continuous optimization problems. When you use JuMP to solve a problem with discrete variables, your solver will likely use a branch-and-bound style method.","category":"page"},{"location":"faq/#Should-I-use-JuMP-or-BooleanSatisfiability?","page":"FAQ","title":"Should I use JuMP or BooleanSatisfiability?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"If you have a problem with mixed real and discrete variables, you should probably use JuMP to call a branch-and-bound solver.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"If you have a problem with only discrete variables, especially a large one, you should consider using an SMT solver.","category":"page"},{"location":"faq/#How-do-I-solve-SMT-problems-in-other-langugages?","page":"FAQ","title":"How do I solve SMT problems in other langugages?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"CVC5 has APIs for C++, Java, and Python.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Z3 has APIs for C, C++, .NET, Java, Python, and ML/OCaml. Additionally, Microsoft Research provides tutorials for using Z3 in Python and JavaScript.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"These are two popular options - there are many more.","category":"page"},{"location":"faq/#Are-there-other-SMT-libraries-in-Julia?","page":"FAQ","title":"Are there other SMT libraries in Julia?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"You can solve integer and Boolean-valued problems in JuMP (see here). There are also Julia bindings for the Z3 C++ API. To our knowledge, this is the first general-purpose SMT library in Julia.","category":"page"},{"location":"faq/#What-about-other-theories-in-the-SMT-standard?","page":"FAQ","title":"What about other theories in the SMT standard?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"In the future support may be added for additional theories supported in the SMTLIB2 standard, such as bitvectors and arrays.","category":"page"},{"location":"faq/#How-can-I-retrieve-a-proof-or-unsat-core-from-the-solver?","page":"FAQ","title":"How can I retrieve a proof or unsat core from the solver?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Unsatisfiability proofs are difficult to support because the SMT2 standard doesn't specify their format - it's solver-dependent. Although we don't provide an explicit function, you can still retrieve a proof in two ways:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Instead of calling sat!, use save to write the SMT representation of your problem to a file. Then invoke the solver from your command line, feed it the file and issue (get-proof) in unsat mode.\nCall sat! on your problem as shown here, then use send_command to issue (get-proof).","category":"page"},{"location":"faq/#What-does-BooleanSatisfiability.jl-actually-do?","page":"FAQ","title":"What does BooleanSatisfiability.jl actually do?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"We provide a high-level interface to SMT solvers. SMT solvers can accept input in the SMT2 format, which is very powerful but not easy to read. When you specify an SMT problem in BooleanSatisfiability.jl and call sat!, we generate an SMT2-formatted representation of the problem, feed it to a solver, then interpret the result.","category":"page"},{"location":"faq/#LFAQ","page":"FAQ","title":"LFAQ","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"(Less frequently-asked questions.)","category":"page"},{"location":"faq/#Why-is-sat!-so-slow-for-real-valued-variables?","page":"FAQ","title":"Why is sat! so slow for real-valued variables?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Because the SMT theory of real-valued variables is incomplete.","category":"page"},{"location":"faq/#Where-do-all-the-long,-ugly-names-in-the-SMT-file-come-from?","page":"FAQ","title":"Where do all the long, ugly names in the SMT file come from?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"To prevent names from being duplicated, BooleanSatisfiability.jl names new expressions using the Julia hash of their child expressions.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"For example, suppose you have","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"@satvariable(a, :Int)\n@satvariable(b, :Int)\nexpr = a <= b\nprint(smt(expr))","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"The (long, ugly) name of the combined expression a <= b is generated by hashing the names a and b.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Q: Why don't you just concatenate a and b and call it LEQ_a_b?","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"A: Because what if we have a = Int(10,\"a\"); expr = sum(a)? Are we going to say expr.name = ADD_a_1_a_2_a_3_a_4_a_5_a_6_a_7_a_8_a_9_a_10? If not, where do we draw the line? What if we called it ADD_a_1__a_10, but then we defined expr2 = a[1] + a[3:8] + a[10]? Then both expr and expr1 would share the name ADD_a_1__a_10 and all heck would break loose.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"If you think of a nicer way to name expressions, please open an issue!","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here we present several mini-examples of SMT problems.","category":"page"},{"location":"tutorial/#Proving-the-validity-of-De-Morgan's-law","page":"Tutorial","title":"Proving the validity of De Morgan's law","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This example is borrowed from Microsoft's introduction to Z3 for propositional logic.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We say a formula is valid if it is true for every assignment of values to its variables. For example, z ∨ ¬z is valid. (This is useful because a valid formula can provide a useful transformation or simplification of a logical expression.)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"One famous transformation is De Morgan's law: a ∧ b = ¬(¬a ∨ ¬b). To show validity of De Morgan's law, we can construct the bidirectional implication a ∧ b ⟺ ¬(¬a ∨ ¬b). It suffices to show that the negation of this formula is unsatisfiable.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@satvariable(a, :Bool)\n@satvariable(b, :Bool)\n\nconjecture = iff(a ∧ b, ¬(¬a ∨ ¬b))\nstatus = sat!(¬conjecture, Z3()) # status will be either :SAT or :UNSAT","category":"page"},{"location":"tutorial/#A-common-logical-mistake","page":"Tutorial","title":"A common logical mistake","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Suppose you have Boolean variables p, q and r. A common mistake made by students in discrete math classes is to think that if p implies q and q implies r ((p ⟹ q) ∧ (q ⟹ r)) then p must imply r (p ⟹ r). Are these statements equivalent? We can use a SAT solver to check.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@satvariable(p, :Bool)\n@satvariable(q, :Bool)\n@satvariable(r, :Bool)\n\nconjecture = iff((p ⟹ q) ∧ (q ⟹ r), p ⟹ r)\nstatus = sat!(¬conjecture, Z3())","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Unlike the previous example the status is :SAT, indicating there is an assignment p, q and r that disproves the conjecture.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"println(\"p = $(value(p))\")\nprintln(\"q = $(value(q))\")\nprintln(\"r = $(value(r))\")","category":"page"},{"location":"tutorial/#Optimizing-over-integers","page":"Tutorial","title":"Optimizing over integers","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The knapsack problem is a famous NP-complete problem in which you are packing a bag that cannot exceed some maximum weight. Given a set of items with known value and weight, you want to pack a subset that maximizes the value.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A simpler version, illustrated in this classic XKCD strip, is to pack the bag to exactly its maximum weight (or spend a specific amount of money). In fact, the problem in the XKCD strip can be expressed as a linear equation over integers.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@satvariable(a[1:6], :Bool)\nc = [215; 275; 335; 355; 420; 580]\nexpr = and([all(a .>= 0), sum(a .* c) == 1505])\nsat!(expr, Z3())\nprintln(\"Result: $(value(a))\")\nprintln(\"Check: $(sum(value(a) .* c))\")","category":"page"}]
}
