var documenterSearchIndex = {"docs":
[{"location":"example_job_shop/#Job-shop-scheduling","page":"Job shop scheduling","title":"Job shop scheduling","text":"","category":"section"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"The job shop scheduling problem is a linear integer problem arising in operations research.","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"Suppose you are managing a machine shop with several different jobs in progress. Each job consists of a series of tasks. Some of the tasks have ordering constraints: e.g. parts must be manufactured before they can be installed in a larger assembly. Due to equipment constraints, we cannot schedule two tasks requiring the same machine at the same time. Additionally, all tasks must have a worker assigned to complete them.","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"In this problem (from Microsoft's Z3 tutorial) we have three jobs, each consisting of one task to be completed first by worker A and one to be completed second by worker B. Each task has an integer-valued duration. Workers cannot work on two tasks at once or take each others' tasks.","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"We'd like to find a solution such that all three jobs can be completed in an 8-hour workday.","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"Define two vector-valued variables t1 and t2 such that tj[i] is the start time of job i for worker j.\nDefine two vector-valued variables d1 and d2 such that dj[i] is the duration of job i for worker j.","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"using BooleanSatisfiability\nn = 3 # number of jobs\nm = 2 # number of tasks per job\nt1 = Int(n,\"t1\")\nt2 = Int(n, \"t2\")\nd1 = [2; 3; 2]\nd2 = [1; 1; 3]","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"A start time of 0 corresponds to the first hour of the workday, and an end time of 8 corresponds to the last hour of the workday.","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"working_hours = all(and.(t1 .>= 0, t2 .+ d2 .<= 8))","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"Sequencing constraint: For each job, A must complete the first task before B can start the second task","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"sequencing = and(t2 .>= t1 .+ d1)","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"Overlap constraint between all permutations","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"overlaps = [(1,2), (1,3), (2,3)]\noverlap_1 = all([or( t1[i] >= t1[j] + d1[j], t1[j] >= t1[i] + d1[i]) for (i,j) in overlaps])\noverlap_2 = all([or( t2[i] >= t2[j] + d2[j], t2[j] >= t2[i] + d2[i]) for (i,j) in overlaps])","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"Solve the problem","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"status = sat!(working_hours, sequencing, overlap_1, overlap_2)\nprintln(\"status = $status\")\nif status == :SAT\n    println(\"t1 = $(value(t1))\")\n    println(\"t2 = $(value(t2))\")\nend","category":"page"},{"location":"example_scheduling/#Finding-a-meeting-time","page":"Finding a meeting time","title":"Finding a meeting time","text":"","category":"section"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"We have n people's availabilities for the meeting times 9a, 10a, 11a, 12, 1p, 2p, 3p, 4p. Each person's availability is reprsented as a Boolean vector a^topin 01^8. We would like to schedule J meetings between different groups of people, represented by J index sets mathcalI_jsubseteq1dotsn.","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"Rules:","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"Each meeting mathcalI_j must occur at one time t.\nAll people attending meeting mathcalI_j must be available at time t.\nAll people attending meeting mathcalI_j must not be attending another meeting at time t.\nNo attendee should have >2 hours of consecutive meetings.","category":"page"},{"location":"example_scheduling/#Setup","page":"Finding a meeting time","title":"Setup","text":"","category":"section"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"We concatenate the availability row vectors into a 5 x 8 Boolean matrix bar A.","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"using BooleanSatisfiability\n\nn = 5 # number of people\nT = 8 # number of times\n\n# nxT matrix: each row is one attendee's meeting availability\nA_bar = Bool[\n    1 0 1 0 1 1 1 1\n    0 1 1 0 0 0 0 1\n    1 1 1 0 1 1 0 1\n    1 1 0 1 1 0 0 0\n    0 1 1 1 0 0 0 1\n]\n\n# A is a matrix-valued variable such that ``A_{it} = 1`` if attendee ``i`` is in a meeting at time ``t`` and 0 otherwise.\nA = Bool(n,T,\"A\")","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"The index_sets represent which meeting attendees are required at each meeting mathcalI_j.","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"index_sets = [[1,2,3], [3,4,5], [1,3,5], [1,4]]\nJ = length(index_sets) # number of meetings","category":"page"},{"location":"example_scheduling/#Logical-constraints","page":"Finding a meeting time","title":"Logical constraints","text":"","category":"section"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"If attendee i is unavailable at time t (bar A_it = 0) then they cannot be in a meeting at time t.","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"unavailability = and(¬A_bar .⟹ ¬A)","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"For each meeting j, all attendees in index set mathcalI_j must be available at some time t and not attending another meeting.","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"M = [and(A[index_sets[j], t]) for j=1:J, t=1:T]\n\n# get a list of conflicts\nconflicts = [filter((i) -> i != j && length(intersect(index_sets[j], index_sets[i])) > 0, 1:J) for j=1:J ]\nno_double_booking = all([M[j,t] ⟹ ¬or(M[conflicts[j],t]) for j=1:J, t=1:T])","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"All meetings must be scheduled.","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"require_one_time = all([or(M[j,:]) for j=1:J])","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"No attendee should have more than 2 consecutive hours of meetings.","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"time_limit = all([¬and(A[i,t:t+2]) for i=1:n, t=1:T-2])","category":"page"},{"location":"example_scheduling/#Solving-the-problem","page":"Finding a meeting time","title":"Solving the problem","text":"","category":"section"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"# solve\nexprs = [no_double_booking, require_one_time, unavailability, time_limit]\nstatus = sat!(exprs)\n\nprintln(\"status = $status\") # for this example we know it's SAT\ntimes = [\"9a\", \"10a\", \"11a\", \"12p\", \"1p\", \"2p\", \"3p\", \"4p\"]\nfor j=1:J\n    println(\"Meeting with attendees $(index_sets[j]) can occur at $(times[findall(value(M[j,:]) .== true)])\")\nend\n\nprintln(\"Value A: $(value(A))\")\nprintln(\"Value N: $(value(M))\")","category":"page"},{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Pages = [\"functions.md\"]\nDepth = 3","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Test link link","category":"page"},{"location":"functions/#Defining-variables","page":"Functions","title":"Defining variables","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Bool(name::String)\nInt(name::String)\nReal(name::String)","category":"page"},{"location":"functions/#Core.Bool-Tuple{String}","page":"Functions","title":"Core.Bool","text":"Bool(\"z\")\n\nConstruct a single Boolean variable with name \"z\".\n\n    Bool(n, \"z\")\n    Bool(m, n, \"z\")\n\nConstruct a vector-valued or matrix-valued Boolean variable with name \"z\".\n\nVector and matrix-valued Booleans use Julia's built-in array functionality: calling Bool(n,\"z\") returns a Vector{BoolExpr}, while calling Bool(m, n, \"z\") returns a Matrix{BoolExpr}.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Core.Int-Tuple{String}","page":"Functions","title":"Core.Int","text":"Int(\"a\")\n\nConstruct a single Int variable with name \"a\".\n\n    Int(n, \"a\")\n    Int(m, n, \"a\")\n\nConstruct a vector-valued or matrix-valued Int variable with name \"a\".\n\nVector and matrix-valued Ints use Julia's built-in array functionality: calling Int(n,\"a\") returns a Vector{IntExpr}, while calling Int(m, n, \"a\") returns a Matrix{IntExpr}.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Core.Real-Tuple{String}","page":"Functions","title":"Core.Real","text":"Real(\"r\")\n\nConstruct a single Int variable with name \"r\".\n\n    Real(n, \"r\")\n    Real(m, n, \"r\")\n\nConstruct a vector-valued or matrix-valued Real variable with name \"r\".\n\nVector and matrix-valued Reals use Julia's built-in array functionality: calling Real(n,\"a\") returns a Vector{RealExpr}, while calling Real(m, n, \"r\") returns a Matrix{RealExpr}.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Logical-operations","page":"Functions","title":"Logical operations","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"These are operations in the theory of propositional logic. For a formal definition of this theory, see Figure 3.2 in The SMT-LIB Standard, Version 2.6.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"not(z::BoolExpr)\nand(z1::BoolExpr, z2::BoolExpr)\nor(z1::BoolExpr, z2::BoolExpr)\nxor(zs_mixed::Array{T}; broadcast_type=:Elementwise) where T\n\nimplies(z1::BoolExpr, z2::BoolExpr)\niff(z1::BoolExpr, z2::BoolExpr)\nite(x::Union{BoolExpr, Bool}, y::Union{BoolExpr, Bool}, z::Union{BoolExpr, Bool})\n\nall(zs::Array{T}) where T <: BoolExpr\nany(zs::Array{T}) where T <: BoolExpr","category":"page"},{"location":"functions/#BooleanSatisfiability.not-Tuple{BoolExpr}","page":"Functions","title":"BooleanSatisfiability.not","text":"not(z::BoolExpr)\n¬z\n\nReturn the logical negation of z.\n\nNote: Broacasting a unary operator requires the syntax .¬z which can be confusing to new Julia users. We define ¬(z::Array{BoolExpr}) for convenience.\n\n    z = Bool(n, \"z\")\n    ¬z  # syntactic sugar for map(¬, z)\n    .¬z # also valid\n\n\n\n\n\n","category":"method"},{"location":"functions/#BooleanSatisfiability.and-Tuple{BoolExpr, BoolExpr}","page":"Functions","title":"BooleanSatisfiability.and","text":"z1 ∧ z2\nand(z1,...,zn)\nand([z1,...,zn])\n\nReturns the logical AND of two or more variables. Use dot broadcasting for vector-valued and matrix-valued Boolean expressions.\n\nz1 = Bool(n, \"z1\")\nz2 = Bool(m, n, \"z2\")\nz1 .∧ z2\nand.(z1, z2) # equivalent to z1 .∧ z2\n\nSpecial cases:\n\nand(z) returns z.\nand(z, false) returns false.\nand(z, true) returns z.\n\n\n\n\n\n","category":"method"},{"location":"functions/#BooleanSatisfiability.or-Tuple{BoolExpr, BoolExpr}","page":"Functions","title":"BooleanSatisfiability.or","text":"z1 ∨ z2\nor(z1,...,zn)\nor([z1,...,zn])\n\nReturns the logical OR of two or more variables. Use dot broadcasting for vector-valued and matrix-valued Boolean expressions.\n\nz1 = Bool(n, \"z1\")\nz2 = Bool(m, n, \"z2\")\nz1 .∨ z2\nor.(z1, z2) # equivalent to z1 .∨ z2\n\nSpecial cases:\n\nor(z) returns z.\nor(z, false) returns z.\nor(z, true) returns true.\n\nNote that ∨ (\\vee) is NOT the ASCII character v.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.xor-Union{Tuple{Array{T}}, Tuple{T}} where T","page":"Functions","title":"Base.xor","text":"xor(z1,...,zn)\n⊻(z1,...zn)\n\nXOR (exclusive or) is true if exactly one of z1,...,zn is true and false otherwise. Use dot broadcasting across arrays.\n\nSpecial cases:\n\nxor(z) returns z.\nxor(false, z) returns z.\nxor(true, z) returns ¬z.\nxor(true, true, z) returns false.\n\n\n\n\n\n","category":"method"},{"location":"functions/#BooleanSatisfiability.implies-Tuple{BoolExpr, BoolExpr}","page":"Functions","title":"BooleanSatisfiability.implies","text":"z1 ⟹ z2\nimplies(z1, z2)\n\nReturns the expression z1 IMPLIES z2. Use dot broadcasting for vector-valued and matrix-valued Boolean expressions. Note: implies(z1, z2) is equivalent to or(not(z1), z2).\n\n\n\n\n\n","category":"method"},{"location":"functions/#BooleanSatisfiability.iff-Tuple{BoolExpr, BoolExpr}","page":"Functions","title":"BooleanSatisfiability.iff","text":"iff(z1::BoolExpr, z2::BoolExpr)\nz1 ⟺ z2\n\nBidirectional implication between z1 and z2. Equivalent to and(z1 ⟹ z2, z2 ⟹ z1).\n\n\n\n\n\n","category":"method"},{"location":"functions/#BooleanSatisfiability.ite-Tuple{Union{Bool, BoolExpr}, Union{Bool, BoolExpr}, Union{Bool, BoolExpr}}","page":"Functions","title":"BooleanSatisfiability.ite","text":"ite(x::BoolExpr, y::BoolExpr, z::BoolExpr)\n\nIf-then-else statement. Equivalent to or(x ∧ y, ¬x ∧ z).\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.all-Union{Tuple{Array{T}}, Tuple{T}} where T<:BoolExpr","page":"Functions","title":"Base.all","text":"all([z1,...,zn])\n\nReturn and(z1,...,zn). If z1,...,zn are themselves AND operations, all(z)flattens the nestedAND`.\n\nExamples:\n\nand([and(z1, z2), and(z3, z4)]) == and(z1, z2, z3, z4)\nand([or(z1, z3), z3, z4]) == and(or(z1, z3), z3, z4)\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.any-Union{Tuple{Array{T}}, Tuple{T}} where T<:BoolExpr","page":"Functions","title":"Base.any","text":"any([z1,...,zn])\n\nReturn or(z1,...,zn). If z1,...,zn are themselves OR operations, any(z)flattens the nestedOR`. Examples:\n\nany([or(z1, z2), or(z3, z4)]) == or(z1, z2, z3, z4)\nany([and(z1, z3), z3, z4]) == or(and(z1, z3), z3, z4)\n\n\n\n\n\n","category":"method"},{"location":"functions/#Arithmetic-operations","page":"Functions","title":"Arithmetic operations","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"These are operations in the theory of integer and real-valued arithmetic.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Note that +, -, and * follow type promotion rules: if both a and b are IntExprs, a+b will have type IntExpr. If either a or b is a RealExpr, the result will have type RealExpr. Division \\ is defined only in the theory of real-valued arithmetic, thus it always has return type RealExpr. For a formal definition of the theory of integer arithmetic, see Figure 3.3 in The SMT-LIB Standard, Version 2.6.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Base.:-(a::IntExpr)\nBase.:+(a::IntExpr, b::IntExpr)\nBase.:-(a::IntExpr, b::IntExpr)\nBase.:*(a::RealExpr, b::RealExpr)\nBase.:/(a::RealExpr, b::RealExpr)","category":"page"},{"location":"functions/#Base.:--Tuple{IntExpr}","page":"Functions","title":"Base.:-","text":"-(a::IntExpr)\n-(r::RealExpr)\n\nReturn the negative of an Int or Real expression.\n\n    -Int(n, \"a\")# this works\n    -Int(n, m, \"b\") # this also works\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:+-Tuple{IntExpr, IntExpr}","page":"Functions","title":"Base.:+","text":"a + b\na + 1 + true\n\nReturn the Int | Real expression a+b (inherits the type of a+b). Use dot broadcasting for vector-valued and matrix-valued Boolean expressions.\n\na = Int(n, \"a\")\nb = Int(n, m, \"b\")\na .+ b\nprintln(\"typeof a+b: $(typeof(a[1] + b[1]))\")\nc = Real(\"c\")\nprintln(\"typeof a+c: $(typeof(a[1] + c))\")\nz = Bool(\"z\")\na .+ z\nprintln(\"typeof a+z: $(typeof(a[1] + z))\")\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:--Tuple{IntExpr, IntExpr}","page":"Functions","title":"Base.:-","text":"a - b\na - 2\n\nReturns the Int | Real expression a-b (inherits the type of a-b). Use dot broadcasting for vector-valued and matrix-valued Boolean expressions.\n\na = Int(n, \"a\")\nb = Int(n, m, \"b\")\na .- b\nprintln(\"typeof a-b: $(typeof(a[1] - b[1]))\")\nc = Real(\"c\")\nprintln(\"typeof a-c: $(typeof(a[1] - c))\")\nz = Bool(\"z\")\na .- z\nprintln(\"typeof a-z: $(typeof(a[1] - z))\")\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:*-Tuple{RealExpr, RealExpr}","page":"Functions","title":"Base.:*","text":"a * b\na * 2\n\nReturns the Int | Real multiplication expression a*b (inherits the type of a*b). Use dot broadcasting for vector-valued and matrix-valued Boolean expressions.\n\na = Int(n, \"a\")\nb = Int(n, m, \"b\")\na .* b\nprintln(\"typeof a*b: $(typeof(a[1]*b[1]))\")\nc = Real(\"c\")\nprintln(\"typeof a*c: $(typeof(a[1]*c))\")\nz = Bool(\"z\")\na .- z\nprintln(\"typeof a*z: $(typeof(a[1]*z))\")\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:/-Tuple{RealExpr, RealExpr}","page":"Functions","title":"Base.:/","text":"a / b\na / 1.0\n\nReturns the Real division expression a/b. Note: a and b must be Real). Use dot broadcasting for vector-valued and matrix-valued Boolean expressions.\n\na = Real(n, \"a\")\nb = Real(n, m, \"b\")\na ./ b\nprintln(\"typeof a/b: $(typeof(a[1]/b[1]))\")\n\n\n\n\n\n","category":"method"},{"location":"functions/#Comparison-operators","page":"Functions","title":"Comparison operators","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Base.:(==)(a::AbstractExpr, b::AbstractExpr)\nBase.:<(a::AbstractExpr, b::AbstractExpr)\nBase.:<=(a::AbstractExpr, b::AbstractExpr)\nBase.:>(a::AbstractExpr, b::AbstractExpr)\nBase.:>=(a::AbstractExpr, b::AbstractExpr)","category":"page"},{"location":"functions/#Base.:<-Tuple{AbstractExpr, AbstractExpr}","page":"Functions","title":"Base.:<","text":"a < b\na < 0\n\nReturns the Boolean expression a < b. Use dot broadcasting for vector-valued and matrix-valued expressions.\n\na = Int(n, \"a\")\nb = Int(n, m, \"b\")\na .< b\nz = Bool(\"z\")\na .< z\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:<=-Tuple{AbstractExpr, AbstractExpr}","page":"Functions","title":"Base.:<=","text":"a <= b\na <= 0\n\nReturns the Boolean expression a <= b. Use dot broadcasting for vector-valued and matrix-valued expressions.\n\na = Int(n, \"a\")\nb = Int(n, m, \"b\")\na .<= b\nz = Bool(\"z\")\na .<= z\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:>-Tuple{AbstractExpr, AbstractExpr}","page":"Functions","title":"Base.:>","text":"a > b\na > 0\n\nReturns the Boolean expression a > b. Use dot broadcasting for vector-valued and matrix-valued expressions.\n\na = Int(n, \"a\")\nb = Int(n, m, \"b\")\na .> b\nz = Bool(\"z\")\na .> z\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:>=-Tuple{AbstractExpr, AbstractExpr}","page":"Functions","title":"Base.:>=","text":"a >= b\na >= 0\n\nReturns the Boolean expression a >= b. Use dot broadcasting for vector-valued and matrix-valued expressions.\n\na = Int(n, \"a\")\nb = Int(n, m, \"b\")\na .>= b\nz = Bool(\"z\")\na .>= z\n\n\n\n\n\n","category":"method"},{"location":"functions/#Generating-the-SMT-representation-of-a-problem","page":"Functions","title":"Generating the SMT representation of a problem","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"smt(zs::Array{T}) where T <: BoolExpr\nsave(prob::BoolExpr; filename=\"out\")","category":"page"},{"location":"functions/#BooleanSatisfiability.smt-Union{Tuple{Array{T}}, Tuple{T}} where T<:BoolExpr","page":"Functions","title":"BooleanSatisfiability.smt","text":"smt(z::AbstractExpr)\nsmt(z1,...,zn)\nsmt([z1,...,zn])\n\nGenerate the SMT representation of z or and(z1,...,zn).\n\nWhen calling smt([z1,...,zn]), the array must have type Array{AbstractExpr}. Note that list comprehensions do not preserve array typing. For example, if z is an array of BoolExpr, [z[i] for i=1:n] will be an array of type Any. To preserve the correct type, use BoolExpr[z[i] for i=1:n].\n\n\n\n\n\n","category":"method"},{"location":"functions/#BooleanSatisfiability.save-Tuple{BoolExpr}","page":"Functions","title":"BooleanSatisfiability.save","text":"save(z::AbstractExpr, filename)\nsave(z::Array{AbstractExpr}, filename=filename)\nsave(z1, z2,..., filename)                  # z1, z2,... are type AbstractExpr\n\nWrite the SMT representation of z or and(z1,...,zn) to filename.smt.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Solving-a-SAT-problem","page":"Functions","title":"Solving a SAT problem","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"sat!(prob::BoolExpr)\nvalue(zs::Array{T}) where T <: AbstractExpr","category":"page"},{"location":"functions/#BooleanSatisfiability.sat!-Tuple{BoolExpr}","page":"Functions","title":"BooleanSatisfiability.sat!","text":"sat!(z::BoolExpr)\nsat!(z1, z2,...)\n\nSolve the SAT problem using Z3. If the problem is satisfiable, update the values of all BoolExprs in prob with their satisfying assignments.\n\nPossible return values are :SAT, :UNSAT, or :ERROR. prob is only modified to add Boolean values if the return value is :SAT.\n\n\n\n\n\n","category":"method"},{"location":"functions/#BooleanSatisfiability.value-Union{Tuple{Array{T}}, Tuple{T}} where T<:AbstractExpr","page":"Functions","title":"BooleanSatisfiability.value","text":"value(z::BoolExpr)\nvalue(z::Array{BoolExpr})\n\nReturns the satisfying assignment of z, or nothing if no satisfying assignment is known. In the array-valued case, returns Array{Bool} or Array{nothing}.\n\nIt's possible to return an array of mixed Bool and nothing. This could occur if some variables in an array do not appear in a problem, because sat!(problem) will not set the values of variables that do not appear in problem.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Miscellaneous-functions","page":"Functions","title":"Miscellaneous functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Base.isequal(a::AbstractExpr, b::AbstractExpr)","category":"page"},{"location":"functions/#Base.isequal-Tuple{AbstractExpr, AbstractExpr}","page":"Functions","title":"Base.isequal","text":"Test equality of two AbstractExprs.\n\n\n\n\n\n","category":"method"},{"location":"#Solving-SMT-Problems-in-Julia","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"","category":"section"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"BooleanSatisfiability.jl is a package for representing Boolean satisfiability (SAT) and selected other satisfiability modulo theories (SMT) problems in Julia. This package provides a simple front-end interface to common SMT solvers, including full support for vector-valued and matrix-valued expressions.","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"Pages = [\"index.md\"]\nDepth = 4","category":"page"},{"location":"#What-is-a-SAT-problem?","page":"Solving SMT Problems in Julia","title":"What is a SAT problem?","text":"","category":"section"},{"location":"#Boolean-variables-and-literals","page":"Solving SMT Problems in Julia","title":"Boolean variables and literals","text":"","category":"section"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"A Boolean variable can only take on the values true or false (0 or 1).","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"The variable z, which could be either true or false, is a variable, while the value true is a literal. Julia provides built-in support for Boolean literals using the Bool type. This package defines the BoolExpr type to represent Boolean variables.","category":"page"},{"location":"#Logical-formulae","page":"Solving SMT Problems in Julia","title":"Logical formulae","text":"","category":"section"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"We can construct a logical formula using Boolean variables, literals, and operators. This package defines four operators. Both the plaintext and mathematical symbols are available.","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"not(z), or ¬z: the negation of z.\nand(z1, z2) or z1 ∧ z2. The n-ary version, and(z1,...,zn), is also available.\nand(z1, z2) or z1 ∨ z2. The n-ary version, and(z1,...,zn), is also available.\nimplies(z1, z2) or z1 ⟹ z2.","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"These expressions can be nested to produce formulae of arbitrary complexity.","category":"page"},{"location":"#SAT-problems","page":"Solving SMT Problems in Julia","title":"SAT problems","text":"","category":"section"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"Given a Boolean expression, the associated SAT problem can be posed as:","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"\"Is there a satisfying assignment of literals (1's and 0's) such that this formula is true?\"","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"If this assignment exists, we say the formula is satisfiable. More than one satisfying assignment may exist for a given formula.\nIf the assignment does not exist, we say the formula is unsatisfiable.","category":"page"},{"location":"#SMT-problems","page":"Solving SMT Problems in Julia","title":"SMT problems","text":"","category":"section"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"Satisfiability modulo theories is a superset of Boolean satisfiability. SMT encompasses many other theories besides Boolean logic, two of which are supported here.","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"In the theory of integers, we can define integer-valued variables and operations such as +, -, * and the comparisons <, <=, ==, =>, >. For example, we could determine whether there exists a satisfying assignment for integers a and b such that a <= b, b <= 1 and a + b >= 2. (There is - set a = 1 and b = 1.)","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"In the theory of reals, we can define real-valued variables and operations. Reals use the same operations as integers, plus division (\\). However, algorithms to solve SMT problems over real variables are often slow and not guaranteed to find a solution. If you have a problem over only real-valued variables, you should use JuMP and a solver like Gurobi instead.","category":"page"},{"location":"#How-does-BooleanSatisfiability.jl-work?","page":"Solving SMT Problems in Julia","title":"How does BooleanSatisfiability.jl work?","text":"","category":"section"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"BooleanSatisfiability.jl provides an interface to SAT solvers that accept input in the SMTLIB2 format. It works by generating the SMT representation of your problem, then invoking a solver to read said file.","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"Currently, Z3 is supported.","category":"page"},{"location":"faq/#FAQ","page":"FAQ","title":"FAQ","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Pages = [\"faq.md\"]\nDepth = 3","category":"page"},{"location":"faq/#Where-can-I-get-help?","page":"FAQ","title":"Where can I get help?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Please open a Github issue! This is a new package and we would love to hear your suggestions, bug reports, feature requests, and other commentary.","category":"page"},{"location":"faq/#Isn't-this-functionality-included-in-JuMP?","page":"FAQ","title":"Isn't this functionality included in JuMP?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"JuMP provides support for integer and Boolean-valued variables, however it is developed primarily to support mathematical optimization over real-valued or integer-valued variables and continuous functions. As such, JuMP interfaces with solvers such as ECOS, MOSEK, and Gurobi that are intended for continuous optimization problems. When you use JuMP to solve a problem with discrete variables, your solver will likely use a branch-and-bound style method.","category":"page"},{"location":"faq/#Should-I-use-JuMP-or-BooleanSatisfiability?","page":"FAQ","title":"Should I use JuMP or BooleanSatisfiability?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"If you have a problem with mixed real and discrete variables, you should probably use JuMP to call a branch-and-bound solver.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"If you have a problem with only discrete variables, especially a large one, you should consider using a SAT solver.","category":"page"},{"location":"faq/#How-do-I-solve-SAT-problems-in-other-langugages?","page":"FAQ","title":"How do I solve SAT problems in other langugages?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Z3 has APIs for C, C++, .NET, Java, Python and ML/OCaml. Additionally, Microsoft Research provides tutorials for using Z3 in Python and JavaScript.","category":"page"},{"location":"faq/#What-about-other-theories-in-the-SMT-standard?","page":"FAQ","title":"What about other theories in the SMT standard?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"In the future support may be added for additional theories supported in the SMTLIB2 standard, such as bitvectors and arrays.","category":"page"},{"location":"faq/#How-can-I-extract-an-unsatisfiability-proof?","page":"FAQ","title":"How can I extract an unsatisfiability proof?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Instead of calling sat!, use save to write the SMT representation of your problem to a file. Then invoke the solver from your command line, feed it the file and issue (get-proof) in unsat mode.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Yes, that was a long way of saying \"we don't support this feature\". (Unsatisfiability proofs are difficult to support because the SMT2 standard doesn't specify their format - it's solver-dependent.) However you can still specify your problem in BooleanSatisfiability.jl and use the generated SMT file any way you like.","category":"page"},{"location":"faq/#What-does-BooleanSatisfiability.jl-actually-do?","page":"FAQ","title":"What does BooleanSatisfiability.jl actually do?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"We provide a high-level interface to SAT solvers. SAT solvers can accept input in the SMT2 format, which is very powerful but not easy to read. When you specify a SAT problem in BooleanSatisfiability.jl and call sat!, we generate an SMT2-formatted representation of the problem, feed it to a solver, then interpret the result.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"You can feed the solver yourself. Call save instead of SAT to write the SMT2 representation of your problem to a file, where you can inspect it or add additional commands.","category":"page"},{"location":"faq/#LFAQ","page":"FAQ","title":"LFAQ","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"(Less frequently-asked questions.)","category":"page"},{"location":"faq/#Where-do-all-the-long,-ugly-names-in-the-SMT-file-come-from?","page":"FAQ","title":"Where do all the long, ugly names in the SMT file come from?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"To prevent names from being duplicated, BooleanSatisfiability.jl names new expressions using the Julia hash of their child expressions.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"For example, suppose you have","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"a = Int(\"a\")\nb = Int(\"b\")\nexpr = a <= b\nprint(smt(expr))","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"The (long, ugly) name of the combined expression a <= b is generated by hashing the names a and b.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Q: Why don't you just concatenate a and b and call it LEQ_a_b?","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"A: Because what if we have a = Int(10,\"a\"); expr = sum(a)? Are we going to say expr.name = ADD_a_1_a_2_a_3_a_4_a_5_a_6_a_7_a_8_a_9_a_10? If not, where do we draw the line? What if we called it ADD_a_1__a_10, but then we defined expr2 = a[1] + a[3:8] + a[10]? Then both expr and expr1 would share the name ADD_a_1__a_10 and all heck would break loose.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"If you think of a nicer way to name expressions, please open an issue!","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here we present several mini-examples of SMT problems.","category":"page"},{"location":"tutorial/#Proving-the-validity-of-De-Morgan's-law","page":"Tutorial","title":"Proving the validity of De Morgan's law","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This example is borrowed from Microsoft's introduction to Z3 for propositional logic.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We say a formula is valid if it is true for every assignment of values to its variables. For example, z ∨ ¬z is valid. (This is useful because a valid formula can provide a useful transformation or simplification of a logical expression.)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"One famous transformation is De Morgan's law: a ∧ b = ¬(¬a ∨ ¬b). To show validity of De Morgan's law, we can construct the bidirectional implication a ∧ b ⟺ ¬(¬a ∨ ¬b). It suffices to show that the negation of this formula is unsatisfiable.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"a = Bool(\"a\")\nb = Bool(\"b\")\n\nconjecture = iff(a ∧ b, ¬(¬a ∨ ¬b))\nstatus = sat!(¬conjecture) # status will be either :SAT or :UNSAT","category":"page"},{"location":"tutorial/#A-common-logical-mistake","page":"Tutorial","title":"A common logical mistake","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Suppose you have Boolean variables p, q and r. A common mistake made by students in discrete math classes is to think that if p implies q and q implies r ((p ⟹ q) ∧ (q ⟹ r)) then p must imply r (p ⟹ r). Are these statements equivalent? We can use a SAT solver to check.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"p = Bool(\"p\")\nq = Bool(\"q\")\nr = Bool(\"r\")\n\nconjecture = iff((p ⟹ q) ∧ (q ⟹ r), p ⟹ r)\nstatus = sat!(¬conjecture)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Unlike the previous example the status is :SAT, indicating there is an assignment p, q and r that disproves the conjecture.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"println(\"p = $(value(p))\")\nprintln(\"q = $(value(q))\")\nprintln(\"r = $(value(r))\")","category":"page"},{"location":"tutorial/#Optimizing-over-integers","page":"Tutorial","title":"Optimizing over integers","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The knapsack problem is a famous NP-complete problem in which you are packing a bag that cannot exceed some maximum weight. Given a set of items with known value and weight, you want to pack a subset that maximizes the value.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A simpler version, illustrated in this classic XKCD strip, is to pack the bag to exactly its maximum weight (or spend a specific amount of money). In fact, the problem in the XKCD strip can be expressed as a linear equation over integers.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"a = Int(6, \"a\")\nc = [215; 275; 335; 355; 420; 580]\nexpr = and([all(a .>= 0), sum(a .* c) == 1505])\nsat!(expr)\nprintln(\"Result: $(value(a))\")\nprintln(\"Check: $(sum(value(a) .* c))\")","category":"page"}]
}
