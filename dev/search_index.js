var documenterSearchIndex = {"docs":
[{"location":"example_bv_lcg/#Predicting-the-output-of-a-tiny-LCG","page":"Predicting the output of a tiny LCG","title":"Predicting the output of a tiny LCG","text":"","category":"section"},{"location":"example_bv_lcg/","page":"Predicting the output of a tiny LCG","title":"Predicting the output of a tiny LCG","text":"This example is \"3.10.1 Cracking LCG with Z3\" from SAT/SMT by Example by Dennis Yurichev.","category":"page"},{"location":"example_bv_lcg/","page":"Predicting the output of a tiny LCG","title":"Predicting the output of a tiny LCG","text":"A linear congruential generator (LCG) is an algorithm for generating pseudo-random numbers in which a series of transformations is used to move from one number to the next. LCGs are easy to implement using low-level bit operations, making them popular for resource-constrained embedded applications. However, they are unsuitable for many applications because their output is predictable.","category":"page"},{"location":"example_bv_lcg/","page":"Predicting the output of a tiny LCG","title":"Predicting the output of a tiny LCG","text":"SAT/SMT by Example, example 3.10.1 shows how to predict the future output of an LCG by encoding its transformations. The original example starts with a small C program that prints the output of rand() % 100 10 times, producing 10 2 digit random numbers. It turns out C's rand() has this LCG implementation:","category":"page"},{"location":"example_bv_lcg/","page":"Predicting the output of a tiny LCG","title":"Predicting the output of a tiny LCG","text":"state = state * 214013 + 2531011\nstate = (state >> 16) & 0x7FFF\nreturn state","category":"page"},{"location":"example_bv_lcg/","page":"Predicting the output of a tiny LCG","title":"Predicting the output of a tiny LCG","text":"Suppose we observe 10 states n1,...,n10 = [37, 29, 74, 95, 98, 40, 23, 58, 61, 17] from the LCG. We want to predict n0, the number before n1, and n11, the number after n10. (These are the numbers from SAT/SMT by Example.)","category":"page"},{"location":"example_bv_lcg/","page":"Predicting the output of a tiny LCG","title":"Predicting the output of a tiny LCG","text":"using Satisfiability\n\n@satvariable(states[1:10], BitVector, 32)\n@satvariable(output_prev, BitVector, 32)\n@satvariable(output_next, BitVector, 32)","category":"page"},{"location":"example_bv_lcg/","page":"Predicting the output of a tiny LCG","title":"Predicting the output of a tiny LCG","text":"transitions = BoolExpr[states[i+1] == states[i] * 214013+2531011 for i=1:9]\nremainders = BoolExpr[\n    output_prev == urem(( states[1] >> 16 ) & 0x7FFF, 100),\n    urem(( states[2] >> 16) & 0x7FFF, 100) == 29,\n    urem(( states[3] >> 16) & 0x7FFF, 100) == 74,\n    urem(( states[4] >> 16) & 0x7FFF, 100) == 95,\n    urem(( states[5] >> 16) & 0x7FFF, 100) == 98,\n    urem(( states[6] >> 16) & 0x7FFF, 100) == 40,\n    urem(( states[7] >> 16) & 0x7FFF, 100) == 23,\n    urem(( states[8] >> 16) & 0x7FFF, 100) == 58,\n    urem(( states[9] >> 16) & 0x7FFF, 100) == 61,\n    output_next == urem(( states[10] >> 16) & 0x7FFF, 100),\n]","category":"page"},{"location":"example_bv_lcg/","page":"Predicting the output of a tiny LCG","title":"Predicting the output of a tiny LCG","text":"expr = and(and(transitions), and(remainders))\nstatus = sat!(expr, solver=CVC5())\nprintln(\"status = $status\")\n\nfor (i,state) in enumerate(states)\n    println(\"state $i = $(value(state))\")\nend\n\n# According to SAT/SMT By Example the previous output is 37 and the next output is 17.\nprintln(\"prev = $(value(output_prev))\")\nprintln(\"next = $(value(output_next))\")","category":"page"},{"location":"example_graph_coloring/#Graph-coloring","page":"Graph coloring","title":"Graph coloring","text":"","category":"section"},{"location":"example_graph_coloring/","page":"Graph coloring","title":"Graph coloring","text":"A classic problem in graph theory is figuring out how to color nodes of a graph such that no two adjacent nodes have the same color. This is useful for things like mapmaking (imagine if your map had two adjacent countries sharing a color!) The chromatic polynomial counts the number of ways a graph can be colored using n colors. For example, this graph","category":"page"},{"location":"example_graph_coloring/","page":"Graph coloring","title":"Graph coloring","text":" (a)\n  | \\\n  | (c)--(d)\n  | /\n (b)","category":"page"},{"location":"example_graph_coloring/","page":"Graph coloring","title":"Graph coloring","text":"can be colored using exactly 3 colors in 12 different ways. Let's use SMT to find all 12 ways to color this graph.","category":"page"},{"location":"example_graph_coloring/","page":"Graph coloring","title":"Graph coloring","text":"using Satisfiability\n@satvariable(nodes[1:4], Int)\n\n# \"There are 3 colors available\"\nlimits = and.(nodes .>= 1, nodes .<= 3)\n\n# \"No adjacent nodes can share a color\"\n(a, b, c, d) = nodes\nconnections = and(a != b, a != c, b != c, c != d)\n\n# \"All 3 colors must be used\"\n# (If you leave this out you can find 24 colorings. But 12 of them will use only 2 colors.)\nall3 = and(or(nodes .== i) for i=1:3)","category":"page"},{"location":"example_graph_coloring/","page":"Graph coloring","title":"Graph coloring","text":"To find all the solutions, we have to exclude solutions as we find them. Suppose we find a satisfying assignment [vars] = [values]. Adding the negation not(and(vars .== values)) to the list of assertions excludes that specific assignment from being found again. Remember: when excluding solutions, negate the whole expression. An easy mistake is and(not(nodes .== value(nodes))), which excludes each node from taking on the particular value we just found (for example, saying \"a cannot be 1\", \"b cannot be 2\"...) instead of excluding the specific combination of all 4 values (\"a cannot be 1 when b is 2,...\").","category":"page"},{"location":"example_graph_coloring/","page":"Graph coloring","title":"Graph coloring","text":"function findall()\n\n    solutions = []\n    open(Z3()) do interactive_solver # the do syntax closes the solver\n        assert!(interactive_solver, limits, connections, all3)\n        i = 1\n        status, assignment = sat!(interactive_solver)\n        while status == :SAT\n            # Try to solve the problem\n            push!(solutions, assignment)\n            println(\"i = $i, status = $status, assignment = $assignment\")\n            assign!(nodes, assignment)\n            \n            # Use assert! to exclude the solution we just found.\n            assert!(interactive_solver, not(and(nodes .== value(nodes))))\n            status, assignment = sat!(interactive_solver)\n            i += 1\n        end\n    end\n    println(\"Found them all!\")\nend\n\nfindall()","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Pages = [\"installation.md\"]\nDepth = 3","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"NOTE: To successfully use this package you will need to install a back-end solver. Z3 and cvc5 are currently supported. You should be able to use other solvers as long as they implement the SMT-LIB standard.","category":"page"},{"location":"installation/#Installing-Satisfiability","page":"Installation","title":"Installing Satisfiability","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"The usual way! using Pkg; Pkg.add(\"Satisfiability\")","category":"page"},{"location":"installation/#Installing-a-Solver","page":"Installation","title":"Installing a Solver","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Satisfiability uses Julia's Base.Process library to interact with solvers. Thus to successfully install a solver for this package, all you need to do is make sure the appropriate command works in your machine's terminal.","category":"page"},{"location":"installation/#Debian-Linux","page":"Installation","title":"Debian Linux","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install Z3, use sudo apt-get install z3. If you can launch Z3 from the command line by typing z3 -smt2 -in, your installation is correct.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install CVC5:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Download the appropriate binary here and save it as cvc5. (Note: if you already have cvc5 installed under the name cvc5-linux, make a symlink to the name cvc5 or customize your solver command to use the name cvc5-linux.)\nSet the executable permission: chmod +x ./cvc5.\nMost users should move the binary to /usr/local/bin. This allows it to be found from the command line.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you can launch CVC5 from the command line by typing cvc5 --interactive --produce-models, your installation is correct.","category":"page"},{"location":"installation/#MacOS","page":"Installation","title":"MacOS","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install Z3","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Download the appropriate zip file for the latest Z3 release and install following the instructions on that page.\nIf you can open your Terminal and launch z3 by typing z3 -smt2 -in, your installation is correct.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install CVC5","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Download the appropriate binary here and save it as cvc5. (Note: if you already have cvc5 installed under another name, make a symlink to the name cvc5 or customize your solver command to use the name you already have.)\nMost users should move the binary to /usr/local/bin. This allows it to be found from the command line.\nIf you can open your Terminal and launch CVC5 by typing cvc5 --interactive --produce-models, your installation is correct.","category":"page"},{"location":"installation/#Windows","page":"Installation","title":"Windows","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install Z3","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Download the appropriate zip file for the latest Z3 release.\nUnzip the file and put it in your applications folder.\nFind z3.exe. Typically this will be in a bin file in your unzipped folder. Don't move it, but make a note of this file path.\nAdd the z3.exe file path to your PATH environment variable (here's how to do this).","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you can open the WIndows command line and launch z3 by typing z3.exe -smt2 -in, your installation is correct.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install cvc5","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Download the latest release of cvc5. Make sure you save the exe file as cvc5.exe, not cvc5-Win64.exe or anything else.\nMake a note of the file path where you put cvc5.exe.\nAdd the cvc5.exe file path to your PATH environment variable (here's how to do this).","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you can open the Windows command line and launch cvc5 by typing cvc5 --interactive --produce-models, your installation is correct.","category":"page"},{"location":"installation/#Installing-Yices","page":"Installation","title":"Installing Yices","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Please follow the official instructions.","category":"page"},{"location":"installation/#Installing-other-solvers","page":"Installation","title":"Installing other solvers","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"The workflow for installing any solver is the same!","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Download the solver\nMake sure you can invoke it from the command line. On Windows this might include adding its location to your system PATH variable.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"The command you use is the command Satisfiability.jl will use. You can specify exactly the command you want by writing solver = Solver(\"My Solver\",program_name –option1 –option2) - see here for more details.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Be aware of the limitations of your back-end solver - check the manual to ensure it supports the theories you plan to use, and make sure you set the right command line flags. If you're having difficulty using another solver, a good troubleshooting step is to save your problem to SMT format in Satisfiability.jl, then feed it to the solver on your command line.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Satisfiability.jl does not warn you if your problem contains a theory or operation that your back-end solver does not support! For example, if you set the wrong theory in Yices, sat! will hang. Future versions of Satisfiability.jl may implement warnings about logic/problem mismatches, however difficulties can arise in maintaining the correctness of these warnings as solvers are updated and improved.","category":"page"},{"location":"example_job_shop/#Job-shop-scheduling","page":"Job shop scheduling","title":"Job shop scheduling","text":"","category":"section"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"The job shop scheduling problem is a linear integer problem arising in operations research.","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"Suppose you are managing a machine shop with several different jobs in progress. Each job consists of a series of tasks. Some of the tasks have ordering constraints: e.g. parts must be manufactured before they can be installed in a larger assembly. Due to equipment constraints, we cannot schedule two tasks requiring the same machine at the same time. Additionally, all tasks must have a worker assigned to complete them.","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"In this problem (from Microsoft's Z3 tutorial) we have three jobs, each consisting of one task to be completed first by worker A and one to be completed second by worker B. Each task has an integer-valued duration. Workers cannot work on two tasks at once or take each others' tasks.","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"We'd like to find a solution such that all three jobs can be completed in an 8-hour workday.","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"Define two vector-valued variables t1 and t2 such that tj[i] is the start time of job i for worker j.\nDefine two vector-valued variables d1 and d2 such that dj[i] is the duration of job i for worker j.","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"using Satisfiability\nn = 3 # number of jobs\nm = 2 # number of tasks per job\n@satvariable(t1[1:n], Int)\n@satvariable(t2[1:n], Int)\nd1 = [2; 3; 2]\nd2 = [1; 1; 3]","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"A start time of 0 corresponds to the first hour of the workday, and an end time of 8 corresponds to the last hour of the workday.","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"working_hours = and(and.(t1 .>= 0, t2 .+ d2 .<= 8))","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"Sequencing constraint: For each job, A must complete the first task before B can start the second task","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"sequencing = and(t2 .>= t1 .+ d1)","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"Overlap constraint between all permutations","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"overlaps = [(1,2), (1,3), (2,3)]\noverlap_1 = and(or( t1[i] >= t1[j] + d1[j], t1[j] >= t1[i] + d1[i]) for (i,j) in overlaps)\noverlap_2 = and(or( t2[i] >= t2[j] + d2[j], t2[j] >= t2[i] + d2[i]) for (i,j) in overlaps)","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"Solve the problem","category":"page"},{"location":"example_job_shop/","page":"Job shop scheduling","title":"Job shop scheduling","text":"status = sat!(working_hours, sequencing, overlap_1, overlap_2, solver=Z3())\nprintln(\"status = $status\")\nif status == :SAT\n    println(\"t1 = $(value(t1))\")\n    println(\"t2 = $(value(t2))\")\nend","category":"page"},{"location":"example_scheduling/#Finding-a-meeting-time","page":"Finding a meeting time","title":"Finding a meeting time","text":"","category":"section"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"We have n people's availabilities for the meeting times 9a, 10a, 11a, 12, 1p, 2p, 3p, 4p. Each person's availability is reprsented as a Boolean vector a^topin 01^8. We would like to schedule J meetings between different groups of people, represented by J index sets mathcalI_jsubseteq1dotsn.","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"Rules:","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"Each meeting mathcalI_j must occur at one time t.\nAll people attending meeting mathcalI_j must be available at time t.\nAll people attending meeting mathcalI_j must not be attending another meeting at time t.\nNo attendee should have >2 hours of consecutive meetings.","category":"page"},{"location":"example_scheduling/#Setup","page":"Finding a meeting time","title":"Setup","text":"","category":"section"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"We concatenate the availability row vectors into a 5 x 8 Boolean matrix bar A.","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"using Satisfiability\n\nn = 5 # number of people\nT = 8 # number of times\n\n# nxT matrix: each row is one attendee's meeting availability\nA_bar = Bool[\n    1 0 1 0 1 1 1 1\n    0 1 1 0 0 0 0 1\n    1 1 1 0 1 1 0 1\n    1 1 0 1 1 0 0 0\n    0 1 1 1 0 0 0 1\n]\n\n# A is a matrix-valued variable such that ``A_{it} = 1`` if attendee ``i`` is in a meeting at time ``t`` and 0 otherwise.\n@satvariable(A[1:n, 1:T], Bool)\n","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"The index_sets represent which meeting attendees are required at each meeting mathcalI_j.","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"index_sets = [[1,2,3], [3,4,5], [1,3,5], [1,4]]\nJ = length(index_sets) # number of meetings","category":"page"},{"location":"example_scheduling/#Logical-constraints","page":"Finding a meeting time","title":"Logical constraints","text":"","category":"section"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"If attendee i is unavailable at time t (bar A_it = 0) then they cannot be in a meeting at time t.","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"unavailability = and(¬A_bar .⟹ ¬A)","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"For each meeting j, all attendees in index set mathcalI_j must be available at some time t and not attending another meeting.","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"M = [and(A[index_sets[j], t]) for j=1:J, t=1:T]\n\n# get a list of conflicts\nconflicts = [filter((i) -> i != j && length(intersect(index_sets[j], index_sets[i])) > 0, 1:J) for j=1:J ]\nno_double_booking = and(M[j,t] ⟹ ¬or(M[conflicts[j],t]) for j=1:J, t=1:T)","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"All meetings must be scheduled.","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"require_one_time = and(or(M[j,:]) for j=1:J)","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"No attendee should have more than 2 consecutive hours of meetings.","category":"page"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"time_limit = and(¬and(A[i,t:t+2]) for i=1:n, t=1:T-2)","category":"page"},{"location":"example_scheduling/#Solving-the-problem","page":"Finding a meeting time","title":"Solving the problem","text":"","category":"section"},{"location":"example_scheduling/","page":"Finding a meeting time","title":"Finding a meeting time","text":"# solve\nexprs = [no_double_booking, require_one_time, unavailability, time_limit]\nstatus = sat!(exprs, solver=Z3())\n\nprintln(\"status = $status\") # for this example we know it's SAT\ntimes = [\"9a\", \"10a\", \"11a\", \"12p\", \"1p\", \"2p\", \"3p\", \"4p\"]\nfor j=1:J\n    Mj_value = value(M[j,:])\n    println(\"Meeting with attendees $(index_sets[j]) can occur at $(times[filter((i) -> Mj_value[i], 1:length(Mj_value))]) .== true)])\")\nend\n\nprintln(\"Value A: $(value(A))\")\nprintln(\"Value N: $(value(M))\")","category":"page"},{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Pages = [\"functions.md\"]\nDepth = 3","category":"page"},{"location":"functions/#Defining-variables","page":"Functions","title":"Defining variables","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Use the @satvariable macro to define a variable.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"@satvariable","category":"page"},{"location":"functions/#Satisfiability.@satvariable","page":"Functions","title":"Satisfiability.@satvariable","text":"@satvariable(z, Bool)\n@satvariable(a[1:n], Int)\n@satvariable(b, BitVector 32)\n\nConstruct a SAT variable with name z, optional array dimensions, and specified type (Bool, Int, Real or BitVector). Note that some  require an optional third parameter.\n\nOne and two-dimensional arrays of variables can be constructed with the following syntax. The result will be a native Julia array.\n\n@satvariable(a[1:n], Int) # an Int vector of length n\n@satvariable(x[1:m, 1:n], Real) # an m x n Int matrix\n\n\n\n\n\n","category":"macro"},{"location":"functions/","page":"Functions","title":"Functions","text":"An uninterpreted function is a function where the mapping between input and output is not known. The task of the SMT solver is then to determine a mapping such that some SMT expression holds true.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"@uninterpreted","category":"page"},{"location":"functions/#Satisfiability.@uninterpreted","page":"Functions","title":"Satisfiability.@uninterpreted","text":"@uninterpreted(f, Int, Bool) # f takes as input IntExpr and returns BoolExpr\n@uninterpreted(g, (BitVector, 32), (BitVector, 32)) # g's input and output values are BitVectors of length 32\n\nDefine an SMT-LIB uninterpreted function. An uninterpreted function can be thought of as an unknown mapping between input and output values. The task of the SMT solver is then to determine whether a mapping exists such that some Boolean statement is true.\n\nFor example, we can ask whether there exists a function f(x)such thatf(f(x)) == x,f(x) == yandx != y`.\n\n@satvariable(x, Bool)\n@satvariable(y, Bool)\n@uninterpreted(f, Bool, Bool)\n\nstatus = sat!(distinct(x,y), f(x) == y, f(f(x)) == x, solver=Z3())\nprintln(\"status = $status\")\n\n\n\n\n\n","category":"macro"},{"location":"functions/#Logical-operations","page":"Functions","title":"Logical operations","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"These are operations in the theory of propositional logic. For a formal definition of this theory, see Figure 3.2 in The SMT-LIB Standard, Version 2.6 or the SMT-LIB Core theory declaration.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"not(z::BoolExpr)\nand(z1::BoolExpr, z2::BoolExpr)\nor(z1::BoolExpr, z2::BoolExpr)\nxor(zs_mixed::Array{T}; broadcast_type=:Elementwise) where T\n\nimplies(z1::BoolExpr, z2::BoolExpr)\niff(z1::BoolExpr, z2::BoolExpr)\nite(x::Union{BoolExpr, Bool}, y::Union{BoolExpr, Bool}, z::Union{BoolExpr, Bool})\ndistinct(z1::BoolExpr, z2::BoolExpr)","category":"page"},{"location":"functions/#Satisfiability.not-Tuple{BoolExpr}","page":"Functions","title":"Satisfiability.not","text":"not(z::BoolExpr)\n¬z\n\nReturn the logical negation of z.\n\nNote: Broacasting a unary operator requires the syntax .¬z which can be confusing to new Julia users. We define ¬(z::Array{BoolExpr}) for convenience.\n\n    @satvariable(z[1:n], Bool)\n    ¬z  # syntactic sugar for map(¬, z)\n    .¬z # also valid\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.and-Tuple{BoolExpr, BoolExpr}","page":"Functions","title":"Satisfiability.and","text":"z1 ∧ z2\nand(z1,...,zn)\nand([z1,...,zn])\n\nReturns the logical AND of two or more variables. Use dot broadcasting for vector-valued and matrix-valued Boolean expressions.\n\n@satvariable(z1[1:n], Bool)\n@satvariable(z2[n, 1:m], Bool)\nz1 .∧ z2\nand.(z1, z2) # equivalent to z1 .∧ z2\n\nSpecial cases:\n\nand(z) returns z.\nand(z, false) returns false.\nand(z, true) returns z.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.or-Tuple{BoolExpr, BoolExpr}","page":"Functions","title":"Satisfiability.or","text":"z1 ∨ z2\nor(z1,...,zn)\nor([z1,...,zn])\n\nReturns the logical OR of two or more variables. Use dot broadcasting for vector-valued and matrix-valued Boolean expressions.\n\n@satvariable(z1[1:n], Bool)\n@satvariable(z2[1:m, 1:n], Bool)\nz1 .∨ z2\nor.(z1, z2) # equivalent to z1 .∨ z2\n\nSpecial cases:\n\nor(z) returns z.\nor(z, false) returns z.\nor(z, true) returns true.\n\nNote that ∨ (\\vee) is NOT the ASCII character v.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.xor-Union{Tuple{Array{T}}, Tuple{T}} where T","page":"Functions","title":"Base.xor","text":"xor(z1,...,zn)\n⊻(z1,...zn)\n\nXOR (exclusive or) is true if exactly one of z1,...,zn is true and false otherwise. Use dot broadcasting across arrays.\n\nSpecial cases:\n\nxor(z) returns z.\nxor(false, z) returns z.\nxor(true, z) returns ¬z.\nxor(true, true, z) returns false.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.implies-Tuple{BoolExpr, BoolExpr}","page":"Functions","title":"Satisfiability.implies","text":"z1 ⟹ z2\nimplies(z1, z2)\n\nReturns the expression z1 IMPLIES z2. Use dot broadcasting for vector-valued and matrix-valued Boolean expressions. Note: implies(z1, z2) is equivalent to or(not(z1), z2).\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.iff-Tuple{BoolExpr, BoolExpr}","page":"Functions","title":"Satisfiability.iff","text":"iff(z1::BoolExpr, z2::BoolExpr)\nz1 ⟺ z2\n\nBidirectional implication between z1 and z2. Equivalent to and(z1 ⟹ z2, z2 ⟹ z1).\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.ite-Tuple{Union{Bool, BoolExpr}, Union{Bool, BoolExpr}, Union{Bool, BoolExpr}}","page":"Functions","title":"Satisfiability.ite","text":"ite(x::BoolExpr, y::BoolExpr, z::BoolExpr)\n\nIf-then-else statement. Equivalent to or(x ∧ y, ¬x ∧ z).\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.distinct-Tuple{BoolExpr, BoolExpr}","page":"Functions","title":"Satisfiability.distinct","text":"distinct(x, y)\ndistinct(zs::Array{AbstractExpr})\n\nReturns the SMT-LIB distinct operator. distinct(x, y) is semantically equal to x != y or not(x == y). The syntax distinct(exprs) where exprs is an array of expressions is shorthand for \"every element of zs is unique\". Thus,\n\n```julia @satvariable(a[1:3], Int)\n\nthis statement is true\n\nisequal(     distinct(a)     and(distinct(a[1], a[2]), distinct(a[1], a[3]), distinct(a[2], a[3]))     ) ````\n\n\n\n\n\n","category":"method"},{"location":"functions/#Arithmetic-operations","page":"Functions","title":"Arithmetic operations","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"These are operations in the theory of integer and real-valued arithmetic.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Note that +, -, and * follow type promotion rules: if both a and b are IntExprs, a+b will have type IntExpr. If either a or b is a RealExpr, the result will have type RealExpr. Division \\ is defined only in the theory of real-valued arithmetic, thus it always has return type RealExpr. For a formal definition of the theory of integer arithmetic, see Figure 3.3 in The SMT-LIB Standard, Version 2.6.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Base.:-(a::IntExpr)\nBase.:+(a::IntExpr, b::IntExpr)\nBase.:-(a::IntExpr, b::IntExpr)\nBase.:*(a::RealExpr, b::RealExpr)\nBase.:/(a::RealExpr, b::RealExpr)","category":"page"},{"location":"functions/#Base.:--Tuple{IntExpr}","page":"Functions","title":"Base.:-","text":"-(a::IntExpr)\n-(r::RealExpr)\n\nReturn the negative of an Int or Real expression.\n\n@satvariable(a[1:n, 1:m], Int)\n-a # this also works\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:+-Tuple{IntExpr, IntExpr}","page":"Functions","title":"Base.:+","text":"a + b\na + 1 + true\n\nReturn the Int | Real expression a+b (inherits the type of a+b). Use dot broadcasting for vector-valued and matrix-valued Boolean expressions.\n\n@satvariable(a[1:n], Int)\n@satvariable(b[1:n, 1:m], Int)\na .+ b\nprintln(\"typeof a+b: $(typeof(a[1] + b[1]))\")\n\n@satvariable(c, Real)\nprintln(\"typeof a+c: $(typeof(a[1] + c))\")\n\n@satvariable(z, Bool)\na .+ z\nprintln(\"typeof a+z: $(typeof(a[1] + z))\")\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:--Tuple{IntExpr, IntExpr}","page":"Functions","title":"Base.:-","text":"a - b\na - 2\n\nReturns the Int | Real expression a-b (inherits the type of a-b). Use dot broadcasting for vector-valued and matrix-valued Boolean expressions.\n\n@satvariable(a[1:n], Int)\n@satvariable(b[1:n, 1:m], Int)\na .- b\nprintln(\"typeof a-b: $(typeof(a[1] - b[1]))\")\n\n@satvariable(c, Real)\nprintln(\"typeof a-c: $(typeof(a[1] - c))\")\n\n@satvariable(z, Bool)\na .- z\nprintln(\"typeof a-z: $(typeof(a[1] - z))\")\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:*-Tuple{RealExpr, RealExpr}","page":"Functions","title":"Base.:*","text":"a * b\na * 2\n\nReturns the Int | Real multiplication expression a*b (inherits the type of a*b). Use dot broadcasting for vector-valued and matrix-valued Boolean expressions.\n\n@satvariable(a[1:n], Int)\n@satvariable(b[1:n, 1:m], Int)\na .* b\nprintln(\"typeof a*b: $(typeof(a[1]*b[1]))\")\n\n@satvariable(c, Real)\nprintln(\"typeof a*c: $(typeof(a[1]*c))\")\n\n@satvariable(z, Bool)\na .- z\nprintln(\"typeof a*z: $(typeof(a[1]*z))\")\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:/-Tuple{RealExpr, RealExpr}","page":"Functions","title":"Base.:/","text":"a / b\na / 1.0\n\nReturns the Real division expression a/b. Note: a and b must be Real). Use dot broadcasting for vector-valued and matrix-valued Boolean expressions.\n\n@satvariable(a[1:n], Real)\n@satvariable(b[1:n, 1:m], Real)\na ./ b\nprintln(\"typeof a/b: $(typeof(a[1]/b[1]))\")\n\n\n\n\n\n","category":"method"},{"location":"functions/#Comparison-operators","page":"Functions","title":"Comparison operators","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"These operators are available for IntExpr, RealExpr, and BitVector SMT variables.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Base.:(==)(a::IntExpr, b::IntExpr)","category":"page"},{"location":"functions/#Base.:==-Tuple{IntExpr, IntExpr}","page":"Functions","title":"Base.:==","text":"a  == b\na == 1.0\n\nReturns the Boolean expression a == b (arithmetic equivalence). Use dot broadcasting for vector-valued and matrix-valued expressions.\n\n@satvariable(a[1:n], Int)\n@satvariable(b[1:n, 1:m], Int)\na .== b\n\nNote: To test whether two AbstractExprs are eqivalent (in the sense that all properties are equal, not in the shared-memory-location sense of ===), use isequal.\n\n\n\n\n\n","category":"method"},{"location":"functions/","page":"Functions","title":"Functions","text":"For BitVector variables, the comparison operators implement unsigned comparison as defined in the SMT-LIB standard theory of BitVectors.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Base.:<(a::IntExpr, b::IntExpr)\nBase.:<=(a::IntExpr, b::IntExpr)\nBase.:>(a::IntExpr, b::IntExpr)\nBase.:>=(a::IntExpr, b::IntExpr)","category":"page"},{"location":"functions/#Base.:<-Tuple{IntExpr, IntExpr}","page":"Functions","title":"Base.:<","text":"a < b\na < 0\n\nReturns the Boolean expression a < b. Use dot broadcasting for vector-valued and matrix-valued expressions.\n\n@satvariable(a[1:n], Int)\n@satvariable(b[1:n, 1:m], Int)\na .< b\n@satvariable(z, Bool)\na .< z\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:<=-Tuple{IntExpr, IntExpr}","page":"Functions","title":"Base.:<=","text":"a <= b\na <= 0\n\nReturns the Boolean expression a <= b. Use dot broadcasting for vector-valued and matrix-valued expressions.\n\n@satvariable(a[1:n], Int)\n@satvariable(b[1:n, 1:m], Int)\na .<= b\n@satvariable(z, Bool)\na .<= z\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:>-Tuple{IntExpr, IntExpr}","page":"Functions","title":"Base.:>","text":"a > b\na > 0\n\nReturns the Boolean expression a > b. Use dot broadcasting for vector-valued and matrix-valued expressions.\n\n@satvariable(a[1:n], Int)\n@satvariable(b[1:n, 1:m], Int)\na .> b\n@satvariable(z, Bool)\na .> z\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:>=-Tuple{IntExpr, IntExpr}","page":"Functions","title":"Base.:>=","text":"a >= b\na >= 0\n\nReturns the Boolean expression a >= b. Use dot broadcasting for vector-valued and matrix-valued expressions.\n\n@satvariable(a[1:n], Int)\n@satvariable(b[1:n, 1:m], Int)\na .>= b\n@satvariable(z, Bool)\na .>= z\n\n\n\n\n\n","category":"method"},{"location":"functions/#BitVector","page":"Functions","title":"BitVector","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"    @satvariable(a, BitVector, 16)\n    @satvariable(b, BitVector, 12)\n\n    a + concat(bvconst(0x0, 4), b)","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"The SMT-LIB standard BitVector is often used to represent operations on fixed-size integers. Thus, BitVectorExprs can interoperate with Julia's native Integer, Unsigned and BigInt types.","category":"page"},{"location":"functions/#Bitwise-operators","page":"Functions","title":"Bitwise operators","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"In addition to supporting the comparison operators above and arithmetic operators +, -, and *, the following BitVector-specific operators are available. Note that unsigned integer division is available using div.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Base.div(a::BitVectorExpr{UInt8}, b::BitVectorExpr{UInt8})","category":"page"},{"location":"functions/#Base.div-Tuple{BitVectorExpr{UInt8}, BitVectorExpr{UInt8}}","page":"Functions","title":"Base.div","text":"div(a::BitVectorExpr, b::BitVectorExpr)\n\nUnsigned integer division of two BitVectors.\n\n\n\n\n\n","category":"method"},{"location":"functions/","page":"Functions","title":"Functions","text":"The bitwise logical operator symbols &, ~ and | are provided for BitVector types instead of the Boolean logic symbols. This matches Julia's use of bitwise logical operators for Unsigned integer types.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Base.:~(a::BitVectorExpr{UInt8})\nBase.:|(a::BitVectorExpr{UInt8}, b::BitVectorExpr{UInt8})\nBase.:&(a::BitVectorExpr{UInt8}, b::BitVectorExpr{UInt8})\nBase.:<<(a::BitVectorExpr{UInt8}, b::BitVectorExpr{UInt8})\nBase.:>>>(a::BitVectorExpr{UInt8}, b::BitVectorExpr{UInt8})\nurem(a::BitVectorExpr{UInt8}, b::BitVectorExpr{UInt8})","category":"page"},{"location":"functions/#Base.:~-Tuple{BitVectorExpr{UInt8}}","page":"Functions","title":"Base.:~","text":"~a\n\nBitwise not.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:|-Tuple{BitVectorExpr{UInt8}, BitVectorExpr{UInt8}}","page":"Functions","title":"Base.:|","text":"a | b\nor(a, b, c...)\n\nBitwise or. For n>2 variables, use the or(...) notation.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:&-Tuple{BitVectorExpr{UInt8}, BitVectorExpr{UInt8}}","page":"Functions","title":"Base.:&","text":"a & b\nand(a, b, c...)\n\nBitwise and. For n>2 variables, use the and(...) notation.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:<<-Tuple{BitVectorExpr{UInt8}, BitVectorExpr{UInt8}}","page":"Functions","title":"Base.:<<","text":"a << b\n\nLogical left shift a << b.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:>>>-Tuple{BitVectorExpr{UInt8}, BitVectorExpr{UInt8}}","page":"Functions","title":"Base.:>>>","text":"a >>> b\n\nLogical right shift a >>> b.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.urem-Tuple{BitVectorExpr{UInt8}, BitVectorExpr{UInt8}}","page":"Functions","title":"Satisfiability.urem","text":"urem(a::BitVectorExpr, b::BitVectorExpr)\n\nUnsigned remainder of BitVector a divided by BitVector b. \n\n\n\n\n\n","category":"method"},{"location":"functions/","page":"Functions","title":"Functions","text":"The following word-level operations are also available in the SMT-LIB standard.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"concat(a::BitVectorExpr{UInt8}, b::BitVectorExpr{UInt8})\nBase.getindex(a::BitVectorExpr{UInt8}, ind::UnitRange{Int64})\nbv2int(a::BitVectorExpr{UInt8})\nint2bv(a::IntExpr, s::Int)","category":"page"},{"location":"functions/#Satisfiability.concat-Tuple{BitVectorExpr{UInt8}, BitVectorExpr{UInt8}}","page":"Functions","title":"Satisfiability.concat","text":"concat(a, b)\nconcat(a, bvconst(0xffff, 16), b, bvconst(0x01, 8), ...)\nconcat(bvconst(0x01, 8), bvconst(0x02, 12)...)\n\nConcatenate BitVectorExprs and constants of varying sizes. To guarantee a constant is the correct bit size, it should be wrapped using bvconst - otherwise its size will be inferred using bitcount.\n\nconcat(a,b) returns a BitVector with size a.length + b.length.\n\nArguments are concatenated such that the first argument to concat corresponds to the most significant bits of the resulting value. Thus:\n\n    expr = concat(bvconst(0x01, 8), bvconst(0x02, 8), bvconst(0x03, 4))\n    println(expr.length) # 20\n    println(expr.value) # 0x01023\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.getindex-Tuple{BitVectorExpr{UInt8}, UnitRange{Int64}}","page":"Functions","title":"Base.getindex","text":"@satvariable(a, BitVector, 8)\na[4:8] # has length 5\na[3]\n\nSlice or index into a BitVector, returning a new BitVector with the appropriate length. This corresponds to the SMT-LIB operation extract.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.bv2int-Tuple{BitVectorExpr{UInt8}}","page":"Functions","title":"Satisfiability.bv2int","text":"@satvariable(b, BitVector, 8)\na = bv2int(b)\n\nWrap BitVectorExpr b, representing a conversion to IntExpr. The value of the integer expression will be limited by the size of the wrapped BitVector. This operation has high overhead and may impact solver performance.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.int2bv-Tuple{IntExpr, Int64}","page":"Functions","title":"Satisfiability.int2bv","text":"@satvariable(a, Int)\nb = int2bv(a, 8)\n\nWrap IntExpr a, representing a conversion to a BitVector of specified length. This operation has high overhead and may impact solver performance.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Utility-functions-for-BitVectors","page":"Functions","title":"Utility functions for BitVectors","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"bitcount(a::Integer)\nnextsize(n::Integer)\nbvconst(c::Integer, size::Int)","category":"page"},{"location":"functions/#Satisfiability.bitcount-Tuple{Integer}","page":"Functions","title":"Satisfiability.bitcount","text":"\"     bitcount(a::Integer)\n\nReturns the minimum number of bits required to store the number a.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.nextsize-Tuple{Integer}","page":"Functions","title":"Satisfiability.nextsize","text":"\"     nextsize(n::Integer)\n\nReturns the smallest unsigned integer type that can store a number with n bits. If n is larger than the largest available type (UInt128), returns type BigInt.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.bvconst-Tuple{Integer, Int64}","page":"Functions","title":"Satisfiability.bvconst","text":"bvconst(0x01, 32)\nbvconst(2, 8)\n\nWraps a nonnegative integer constant for interoperability with BitVectorExprs. While the correct size of a BitVector constant can usually be inferred (for example, if a is a BitVector of length 16, the constant in a + 0x0f can also be wrapped to length 16), in a few cases it cannot.\n\nSpecifically, when concatenating BitVectorExprs and constants, one should wrap the constants in bvconst to ensure their size matches your expectations.\n\nbvconst will pad constants to the requested size, but will not truncate constants. For example, bvconst(0xffff, 12) yields an error because 0xffff` requires 16 bits.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Additional-Z3-BitVector-operators.","page":"Functions","title":"Additional Z3 BitVector operators.","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Z3 implements the following signed comparisons for BitVectors. Note that these are not part of the SMT-LIB standard and other solvers may not support them.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Base.:>>(a::BitVectorExpr{UInt8}, b::BitVectorExpr{UInt8})\nsrem(a::BitVectorExpr{UInt8}, b::BitVectorExpr{UInt8})\nsmod(a::BitVectorExpr{UInt8}, b::BitVectorExpr{UInt8})\nnor(a::BitVectorExpr{UInt8}, b::BitVectorExpr{UInt8})\nnand(a::BitVectorExpr{UInt8}, b::BitVectorExpr{UInt8})\nxnor(a::BitVectorExpr{UInt8}, b::BitVectorExpr{UInt8})","category":"page"},{"location":"functions/#Base.:>>-Tuple{BitVectorExpr{UInt8}, BitVectorExpr{UInt8}}","page":"Functions","title":"Base.:>>","text":"a >> b\n\nArithmetic right shift a >> b. This operator is not part of the SMT-LIB standard BitVector theory: it is implemented by Z3. It may not be available when using other solvers.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.srem-Tuple{BitVectorExpr{UInt8}, BitVectorExpr{UInt8}}","page":"Functions","title":"Satisfiability.srem","text":"srem(a::BitVectorExpr, b::BitVectorExpr)\n\nSigned remainder of BitVector a divided by BitVector b. This operator is not part of the SMT-LIB standard BitVector theory: it is implemented by Z3. It may not be available when using other solvers.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.smod-Tuple{BitVectorExpr{UInt8}, BitVectorExpr{UInt8}}","page":"Functions","title":"Satisfiability.smod","text":"smod(a::BitVectorExpr, b::BitVectorExpr)\n\nSigned modulus of BitVector a divided by BitVector b. This operator is not part of the SMT-LIB standard BitVector theory: it is implemented by Z3. It may not be available when using other solvers.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.nor-Tuple{BitVectorExpr{UInt8}, BitVectorExpr{UInt8}}","page":"Functions","title":"Base.nor","text":"nor(a, b)\na ⊽ b\n\nBitwise nor. This operator is not part of the SMT-LIB standard BitVector theory: it is implemented by Z3. It may not be available when using other solvers. When using other solvers, write ~(a | b) isntead of nor(a,b).\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.nand-Tuple{BitVectorExpr{UInt8}, BitVectorExpr{UInt8}}","page":"Functions","title":"Base.nand","text":"nand(a, b)\na ⊼ b\n\nBitwise nand. This operator is not part of the SMT-LIB standard BitVector theory: it is implemented by Z3. It may not be available when using other solvers. When using other solvers, write ~(a & b) isntead of nand(a,b).\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.xnor-Tuple{BitVectorExpr{UInt8}, BitVectorExpr{UInt8}}","page":"Functions","title":"Satisfiability.xnor","text":"xnor(a, b)\nxnor(a, b, c...)\n\nBitwise xnor. When n>2 operands are provided, xnor is left-associative (that is, xnor(a, b, c) = reduce(xnor, [a,b,c]). This operator is not part of the SMT-LIB standard BitVector theory: it is implemented by Z3. It may not be available when using other solvers. When using other solvers, write (a & b) | (~a & ~b).\n\n\n\n\n\n","category":"method"},{"location":"functions/","page":"Functions","title":"Functions","text":"Signed comparisons are also Z3-specific.","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"slt(a::BitVectorExpr{UInt8}, b::BitVectorExpr{UInt8})\nsle(a::BitVectorExpr{UInt8}, b::BitVectorExpr{UInt8})\nsgt(a::BitVectorExpr{UInt8}, b::BitVectorExpr{UInt8})\nsge(a::BitVectorExpr{UInt8}, b::BitVectorExpr{UInt8})","category":"page"},{"location":"functions/#Satisfiability.slt-Tuple{BitVectorExpr{UInt8}, BitVectorExpr{UInt8}}","page":"Functions","title":"Satisfiability.slt","text":"\"     slt(a::BitVectorExpr, b::BitVectorExpr)\n\nSigned less-than. This is not the same as a < b (unsigned BitVectorExpr comparison). This operator is not part of the SMT-LIB standard BitVector theory: it is implemented by Z3. It may not be available when using other solvers.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.sle-Tuple{BitVectorExpr{UInt8}, BitVectorExpr{UInt8}}","page":"Functions","title":"Satisfiability.sle","text":"sle(a::BitVectorExpr, b::BitVectorExpr)\n\nSigned less-than-or-equal. This is not the same as a <+ b (unsigned BitVectorExpr comparison). This operator is not part of the SMT-LIB standard BitVector theory: it is implemented by Z3. It may not be available when using other solvers.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.sgt-Tuple{BitVectorExpr{UInt8}, BitVectorExpr{UInt8}}","page":"Functions","title":"Satisfiability.sgt","text":"sgt(a::BitVectorExpr, b::BitVectorExpr)\n\nSigned greater-than. This is not the same as a > b (unsigned BitVectorExpr comparison). This operator is not part of the SMT-LIB standard BitVector theory: it is implemented by Z3. It may not be available when using other solvers.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.sge-Tuple{BitVectorExpr{UInt8}, BitVectorExpr{UInt8}}","page":"Functions","title":"Satisfiability.sge","text":"sge(a::BitVectorExpr, b::BitVectorExpr)\n\nSigned greater-than-or-equal. This is not the same as a >= b (unsigned BitVectorExpr comparison). This operator is not part of the SMT-LIB standard BitVector theory: it is implemented by Z3. It may not be available when using other solvers.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Generating-the-SMT-representation-of-a-problem","page":"Functions","title":"Generating the SMT representation of a problem","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"smt(zs::Array{T}) where T <: BoolExpr\nsave(prob::BoolExpr, io::IO)","category":"page"},{"location":"functions/#Satisfiability.smt-Union{Tuple{Array{T}}, Tuple{T}} where T<:BoolExpr","page":"Functions","title":"Satisfiability.smt","text":"smt(z::AbstractExpr)\nsmt(z1,...,zn; assert=true)\nsmt([z1,...,zn]; assert=true, line_ending='\n\n', as_list=true)\n\nGenerate the SMT representation of z or and(z1,...,zn).\n\nWhen calling smt([z1,...,zn]), the array must have type Array{AbstractExpr}. Note that list comprehensions do not preserve array typing. For example, if z is an array of BoolExpr, [z[i] for i=1:n] will be an array of type Any. To preserve the correct type, use BoolExpr[z[i] for i=1:n].\n\nOptional keyword arguments are:\n\nassert = true|false: default true. Whether to generate the (assert ...) SMT-LIB statement, which asserts that an expression must be true. This option is only valid if smt is called on a Boolean expression.\nline_ending: If not set, this defaults to \"\n\n\" on Windows and ' ' everywhere else.\n\nas_list = true|false: default false. When true, smt returns a list of commands instead of a single line_ending-separated string.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Solving-a-SAT-problem","page":"Functions","title":"Solving a SAT problem","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"sat!(prob::BoolExpr)\nvalue(zs::Array{T}) where T <: AbstractExpr","category":"page"},{"location":"functions/#Satisfiability.sat!-Tuple{BoolExpr}","page":"Functions","title":"Satisfiability.sat!","text":"sat!(z::BoolExpr, solver=Z3())\nsat!(z1, z2,..., solver=CVC5())\n\nSolve the SAT problem using a Solver. If the problem is satisfiable, update the values of all BoolExprs in prob with their satisfying assignments.\n\nPossible return values are :SAT, :UNSAT, or :ERROR. prob is only modified to add Boolean values if the return value is :SAT. By default, sat! will reset the values of expressions in prob to nothing if prob is unsatisfiable. To change this behavior use the keyword argument clear_values_if_unsat. For example,sat!(prob, solver=CVC5(), clear_values_if_unsat=false).\n\nAlternate usage:\n\njulia     io = open(\"some_file.smt\")     status, values = sat!(io::IO, solver=CVC5())     status, values = sat!(filename::String, solver=CVC5())In io mode, sat! reads the contents of the Julia IO object and passes them to the solver. Thus, users must ensureread(io)will return a complete and correct string of SMT-LIB commands, including(check-sat)or equivalent. Alternatively, one can pass in a filename to be opened and closed withinsat!. Because the expressions are not passed into the function,sat!` returns a dictionary containing the satisfying assignment.\n\nOptional keyword arguments:\n\nsolver::Solver: The Solver to use. Defaults to Z3().\nlogic: Manually set the solver logic. Must be a string corresponding to a valid SMT-LIB logic. If you're unsure how to set this option, don't set it - most solvers can infer the logic to use on their own!\nline_ending::String: The line ending to use after each SMT-LIB command. Defaults to \"\\r\\n\" on Windows and \"\\n\" everywhere else.\nclear_values_if_unsat=true: If true and the expression is unsat, reset its values to nothing.\nstart_commands::String: Additional SMT-LIB commands to be included before the expression, for example (set-logic LOGIC).\nend_commands::String : Additional SMT-LIB commands to be included after the expression.\n\n\n\n\n\ninteractive_solver = open(Z3()) # open an InteractiveSolver process\nstatus, values = sat!(interactive_solver, exprs...) # check satisfiability of exprs\n\nWhen working with an InteractiveSolver process, issues the (check-sat) command. The optional exprs, if provided, will be assumed when (check-sat) is issued but not asserted on the stack. This is equivalent to the SMT-LIB (check-sat-assuming expr1, expr2,...) command.\n\nIf no assertions have been made, sat! throws an error.\n\nNote that in this mode, sat! can only set the values of exprs provided in the function call That means if you assert(expr1) and then call sat!(interactive_solver, expr2), value(expr1) will be nothing even if the problem is SAT. To alleviate this, sat! returns (status, values) where values is a Dict of variable names and satisfying assignments. To assign the values of expr1, call assign!(values, expr1).\n\nOptional keyword arguments:\n\nlogic: Manually set the solver logic. Must be a string corresponding to a valid SMT-LIB logic. If you're unsure how to set this option, don't set it - most solvers can infer the logic to use on their own!\nline_ending::String: The line ending to use after each SMT-LIB command. Defaults to \"\\r\\n\" on Windows and \"\\n\" everywhere else.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.value-Union{Tuple{Array{T}}, Tuple{T}} where T<:AbstractExpr","page":"Functions","title":"Satisfiability.value","text":"value(z::BoolExpr)\nvalue(z::Array{BoolExpr})\n\nReturns the satisfying assignment of z, or nothing if no satisfying assignment is known. In the array-valued case, returns Array{Bool} or Array{nothing}.\n\nIt's possible to return an array of mixed Bool and nothing. This could occur if some variables in an array do not appear in a problem, because sat!(problem) will not set the values of variables that do not appear in problem.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Interacting-with-solvers","page":"Functions","title":"Interacting with solvers","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"open(solver::Solver)\nclose(solver::InteractiveSolver)\npush!(solver::InteractiveSolver, n::Integer)\npop!(solver::InteractiveSolver, n::Integer)\nassert!(solver::InteractiveSolver, exprs::BoolExpr)\nsat!(solver::InteractiveSolver, exprs::BoolExpr)\nsend_command(solver::InteractiveSolver, cmd::String)\nnested_parens_match(solver_output::String)\nis_sat_or_unsat(solver_output::String)\nparse_model(model::String)\nassign!(e::AbstractExpr, d::Dict)\nreset!(s::InteractiveSolver)\nreset_assertions!(s::InteractiveSolver)","category":"page"},{"location":"functions/#Base.open-Tuple{Solver}","page":"Functions","title":"Base.open","text":"interactive_solver = open(s::Solver)\n\nOpen a solver in a new process with in, out, and err pipes. Uses Base.process. Check the source code to see the exact implementation.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.close-Tuple{InteractiveSolver}","page":"Functions","title":"Base.close","text":"close(s::InteractiveSolver)\n\nClose an InteractiveSolver, cleaning up and terminating its processes and pipes.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.push!-Tuple{InteractiveSolver, Integer}","page":"Functions","title":"Base.push!","text":"push!(solver::InteractiveSolver, n=1)\n\nPush n empty assertion levels onto the solver's assertion stack. Usually push!(solver, 1) is sufficient. If n is 0, no assertion levels are pushed. This corresponds exactly to the SMT-LIB command (push n).\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.pop!-Tuple{InteractiveSolver, Integer}","page":"Functions","title":"Base.pop!","text":"pop!(solver::InteractiveSolver, n=1)\n\nPop n empty assertion levels off the solver's assertion stack. If n is 0, no assertion levels are pushed. This corresponds exactly to the SMT-LIB command (pop n).\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.assert!-Tuple{InteractiveSolver, BoolExpr}","page":"Functions","title":"Satisfiability.assert!","text":"assert!(interactive_solver, expr1, expr2...)\nassert!(interactive_solver, exprs::Array)\n\nAssert some expressions. interactive_solver must be an open InteractiveSolver process.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.sat!-Tuple{InteractiveSolver, BoolExpr}","page":"Functions","title":"Satisfiability.sat!","text":"interactive_solver = open(Z3()) # open an InteractiveSolver process\nstatus, values = sat!(interactive_solver, exprs...) # check satisfiability of exprs\n\nWhen working with an InteractiveSolver process, issues the (check-sat) command. The optional exprs, if provided, will be assumed when (check-sat) is issued but not asserted on the stack. This is equivalent to the SMT-LIB (check-sat-assuming expr1, expr2,...) command.\n\nIf no assertions have been made, sat! throws an error.\n\nNote that in this mode, sat! can only set the values of exprs provided in the function call That means if you assert(expr1) and then call sat!(interactive_solver, expr2), value(expr1) will be nothing even if the problem is SAT. To alleviate this, sat! returns (status, values) where values is a Dict of variable names and satisfying assignments. To assign the values of expr1, call assign!(values, expr1).\n\nOptional keyword arguments:\n\nlogic: Manually set the solver logic. Must be a string corresponding to a valid SMT-LIB logic. If you're unsure how to set this option, don't set it - most solvers can infer the logic to use on their own!\nline_ending::String: The line ending to use after each SMT-LIB command. Defaults to \"\\r\\n\" on Windows and \"\\n\" everywhere else.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.send_command-Tuple{InteractiveSolver, String}","page":"Functions","title":"Satisfiability.send_command","text":"send_command(pstdin::Base.Pipe, pstdout::Base.Pipe, cmd::String; is_done=nested_parens_match, timeout=Inf, line_ending='\n\n')\n\nOpen a solver in a new process with in, out, and err pipes. Uses Base.process. Check the source code to see the exact implementation.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.nested_parens_match-Tuple{String}","page":"Functions","title":"Satisfiability.nested_parens_match","text":"nested_parens_match(output::String)\n\nReturn true if output has > 0 length and an equal number of left ( and right ), which can be 0.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.is_sat_or_unsat-Tuple{String}","page":"Functions","title":"Satisfiability.is_sat_or_unsat","text":"is_sat_or_unsat(output::String)\n\nReturn true if output contains \"sat\" or \"unsat\".\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.parse_model-Tuple{String}","page":"Functions","title":"Satisfiability.parse_model","text":"output = \"(\n(define-fun x () Bool true)\n(define-fun y () Bool false)\n(define-fun f ((x!0 Bool)) Bool (ite (= x!0 false) true false))\"\ndict = parse_model(output)\n\nParse the SMT-LIB-formatted output of (get-model), returning a Dict of names and values. Values will be of the correct type; thus, in the example dict[\"x\"] will be true. Uninterpreted function values will be Julia functions themselves, thus dict[\"f\"] is a function that accepts a Bool and returns a Bool.\n\nThis function is primarily useful when working with InteractiveSolvers.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.assign!-Tuple{AbstractExpr, Dict}","page":"Functions","title":"Satisfiability.assign!","text":"assign!(e::AbstractExpr, assignment::Dict)\nassign!(exprs::Array, assignment::Dict)\n\nAssigns the values of expressions in e (including nested expressions and variables) using assignment, a Dict where every key is a string corresponding to an expression name, and the corresponding value is its satisfying assignment.\n\nassign! is intended to be useful in two cases.\n\nUsing an assignment dict returned by sat! in interactive mode.This looks like:\n\n    # define some exprs\n    interactive_solver = open(solver)\n    assert(interactive_solver, exprs...)\n    status, assignment = sat!(interactive_solver)\n    assign!.(exprs, assignment)\n\nUsing an assignment dict returned by parse_model, which parses the raw SMT-LIB output of \"(get-model)\".\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.reset!-Tuple{InteractiveSolver}","page":"Functions","title":"Satisfiability.reset!","text":"reset!(solver::InteractiveSolver)\n\nResets the solver to its state when first opened, clearning InteractiveSolver.command_history. See section 4.2.1 of the SMT-LIB standard.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Satisfiability.reset_assertions!-Tuple{InteractiveSolver}","page":"Functions","title":"Satisfiability.reset_assertions!","text":"reset_assertions!(solver::InteractiveSolver)\n\nRemoves all assertions, popping n levels off the solver's assertion stack. After this command, the stack will be at level 1 and there will be no assertions set. See section 4.2.1 of the SMT-LIB standard.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Miscellaneous-functions","page":"Functions","title":"Miscellaneous functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"isequal(a::AbstractExpr, b::AbstractExpr)","category":"page"},{"location":"functions/#Base.isequal-Tuple{AbstractExpr, AbstractExpr}","page":"Functions","title":"Base.isequal","text":"Test equality of two AbstractExprs. To construct an equality constraint, use ==.\n\n\n\n\n\n","category":"method"},{"location":"interactive/#Interactive-solving","page":"Interactive solving","title":"Interactive solving","text":"","category":"section"},{"location":"interactive/","page":"Interactive solving","title":"Interactive solving","text":"Pages = [\"interactive.md\"]\nDepth = 3","category":"page"},{"location":"interactive/","page":"Interactive solving","title":"Interactive solving","text":"The simplest way to solve an SMT problem is to call sat!. Under the hood, sat! translates your problem to the SMT-LIB format, spawns a solver in a new process, feeds in your problem and, if it's satisfiable, requests the satisfying assignment.","category":"page"},{"location":"interactive/","page":"Interactive solving","title":"Interactive solving","text":"However, many use cases require ongoing interaction with the SMT solver. Satisfiability.jl provides this functionality using the InteractiveSolver struct, allowing users to interface with a running solver process. A typical interactive workflow looks like this.","category":"page"},{"location":"interactive/","page":"Interactive solving","title":"Interactive solving","text":"Construct some expressions","category":"page"},{"location":"interactive/","page":"Interactive solving","title":"Interactive solving","text":"using Satisfiability\n@satvariable(x, Bool)\n@satvariable(y, Bool)\n@satvariable(z, Bool)\nexpr1 = or(and(not(x), y), and(not(y), x))\nexpr2 = not(z)","category":"page"},{"location":"interactive/","page":"Interactive solving","title":"Interactive solving","text":"Spawn a solver process","category":"page"},{"location":"interactive/","page":"Interactive solving","title":"Interactive solving","text":"interactive_solver = open(Z3())","category":"page"},{"location":"interactive/","page":"Interactive solving","title":"Interactive solving","text":"Make some assertions.","category":"page"},{"location":"interactive/","page":"Interactive solving","title":"Interactive solving","text":"assert!(interactive_solver, expr1, expr2)","category":"page"},{"location":"interactive/","page":"Interactive solving","title":"Interactive solving","text":"Check satisfiability. In interactive solver mode, you can provide more expressions to sat!; this would look like sat!(interactive_solver, expr3, expr4...). Since sat! only receives the solver object, it's not able to set the values of expr1 and expr2. Instead, it will return a dictionary containing the satisfying assignment. You can then set your expressions' values using assign!.","category":"page"},{"location":"interactive/","page":"Interactive solving","title":"Interactive solving","text":"status, assignment = sat!(interactive_solver)\nif status == :SAT\n    assign!(expr1, assignment)\n    assign!(expr2, assignment)\n    println(\"Values of x, y, z: x=$(value(x)), y=$(value(y)), z=$(value(z)))\")\nend","category":"page"},{"location":"interactive/","page":"Interactive solving","title":"Interactive solving","text":"Do other stuff, then close your process.","category":"page"},{"location":"interactive/","page":"Interactive solving","title":"Interactive solving","text":"close(interactive_solver)","category":"page"},{"location":"interactive/","page":"Interactive solving","title":"Interactive solving","text":"The Graph Coloring example uses interactivity to find every solution to a problem.","category":"page"},{"location":"interactive/#Managing-the-assertion-stack","page":"Interactive solving","title":"Managing the assertion stack","text":"","category":"section"},{"location":"interactive/","page":"Interactive solving","title":"Interactive solving","text":"SMT-LIB implements the concept of an assertion stack. Pushing a level onto the stack allows you to assert statements, then pop that level off, erasing the assertions and declarations you made. This is useful when incrementally adding constraints to a problem. Finding Bad Assertions provides an example of using push and pop or sat!(solver, exprs...) to manage assertions.","category":"page"},{"location":"interactive/#How-can-I-get-more-control-over-the-solver?","page":"Interactive solving","title":"How can I get more control over the solver?","text":"","category":"section"},{"location":"interactive/","page":"Interactive solving","title":"Interactive solving","text":"If you need more granular control over solver commands and responses, check our guide on advanced usage. For suggestions, feel free to open a GitHub issue! This is a new package and we'd like to hear user feedback. ","category":"page"},{"location":"interactive/","page":"Interactive solving","title":"Interactive solving","text":"!!! warning Don't set print-success","category":"page"},{"location":"interactive/","page":"Interactive solving","title":"Interactive solving","text":"If you set the SMT-LIB option (set-option :print-success true) it will confuse the output parser. Future versions of Satisfiability.jl will address this issue.","category":"page"},{"location":"advanced/#Advanced-usage","page":"Advanced usage","title":"Advanced usage","text":"","category":"section"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"Pages = [\"advanced.md\"]\nDepth = 3","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"Note: Some of the options described on this page require you to use the SMTLIB2 specification language directly.","category":"page"},{"location":"advanced/#Custom-solver-options-and-using-other-solvers","page":"Advanced usage","title":"Custom solver options and using other solvers","text":"","category":"section"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"To customize solver options or use a different (unsupported) solver, use the syntax","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"solver = Solver(\"My Solver\", `program_name --option1 --option2`)\nsat!(problem, solver=solver) # sat! will use your provided command to invoke the solver","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"The command you provide must launch a solver that accepts SMTLIB2-formatted commands and can respond to (get-model) in SAT mode. (An example of a command that does NOT work is cvc5 --interactive, because CVC5 cannot answer (get-model) without the --produce-models option.)","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"To familiarize yourself with what this means, you may use save to generate a small SMT file for a satisfiable problem, then call a solver from the terminal, paste in the contents of your SMT file, and issue the command (get-model). This is exactly what Satisfiability.jl does when you call  sat!. Armed with this knowledge, go forth and customize your solver command.","category":"page"},{"location":"advanced/#Setting-the-solver-logic","page":"Advanced usage","title":"Setting the solver logic","text":"","category":"section"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"You can set the solver logic using an optional keyword argument in sat!. The solver logic must be a string corresponding to a valid SMT-LIB logic. Users are responsible for selecting a logic that reflects the problem they intend to solve - Satisfiability.jl does not perform any correctness checking.","category":"page"},{"location":"advanced/#Custom-interactions-using-send_command","page":"Advanced usage","title":"Custom interactions using send_command","text":"","category":"section"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"Satisfiability.jl provides an interface to issue SMT-LIB commands and receive SMT-LIB-formatted solver responses programmatically. This is useful if you wish to build your own decision logic or parser using advanced solver functionality.","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"If you just want to use an SMT solver interactively, for example by pushing or popping assertions, check out Interactive Solving.","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"!!! note SMT-LIB solver modes.","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"In the SMT-LIB specification, after entering a problem and issuing the command (check-sat) the solver will be in either sat or unsat mode. The solver mode determines which commands are valid: for example, (get-unsat-core) is only valid in unsat mode and (get-model) is only valid in sat mode. You can find descriptions of modes and listings of valid commands in the latest SMT-LIB Standard.","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"Here's an example.","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"@satvariable(x[1:2], Bool)\nexpr = (x[1] ∧ ¬x[1]) ∧ or(x) # unsat\n\ninteractive_solver = open(Z3())\n\nsend_command(interactive_solver, \"(set-option :produce-unsat-cores true)\", dont_wait=true)\n\n# smt() adds the command (check-sat), so Z3 will be in either `sat` or `unsat` mode after this command.\ninput = smt(expr)*\"\\n(check-sat)\\n\"\nresponse = send_command(interactive_solver, input, is_done=is_sat_or_unsat)\n\nprintln(\"status = $response\") # \"unsat\"\n\nresponse = send_command(interactive_solver, \"(get-unsat-core)\", is_done=nested_parens_match)\nprintln(response)\n\n# more interactions via `send_command`...\n\n# it's good form to clean up your open solver process\nclose(interactive_solver)","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"When using this functionality, you are responsible for keeping track of the solver mode and parsing the result of send_command. For convenience, parse_model(model::String) can parse the result of the SMT-LIB command (get-model), returning a dictionary with variable names as keys and satisfying assignments as values.","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"Checking if the response is complete Receiving a complete solver response is not as simple as it sounds, for two reasons.","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"The solver may take a long time to respond, for example when calling (check-sat).\nThe solver's response may be large, thus it may be received in several chunks.","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"The send_command function has an optional argument is_done for checking whether the full response has been received. Two convenience functions are provided: nested_parens_match(response::String) returns true if response begins with ( and ends with a matching ). This ensures the entire output is returned when issuing commands such as (get-model) where the entire response is wrapped in 1 set of parentheses. Many solver responses follow this format. is_sat_or_unsat is very simple: if the response contains sat or unsat it returns true, otherwise it's false.","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"!!! warning Multiple parenthesized statements","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"If your command produces a response with multiple separate statements, for example (statement_1)\\n(statement_2), nested_parens_match is not guaranteed to return the entire response. The intended use case is ((statement_1)\\n(statement_2)). This should only happen if you issue two SMT-LIB commands at once.","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"Customizing is_done","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"A custom function is_done(response::String)::Bool, should have the following behavior:","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"is_done returns true if the given response is valid (in whatever sense you define) and false if not.\nsend_command will WAIT for more output while is_done is false.","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"SAT solvers can be slow and some commands produce long outputs. Without is_done, send_command could receive a partial response and prematurely return.","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"For full implementation details, please see the source code of call_solver.jl.","category":"page"},{"location":"faq/#FAQ","page":"FAQ","title":"FAQ","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Pages = [\"faq.md\"]\nDepth = 3","category":"page"},{"location":"faq/#Where-can-I-get-help?","page":"FAQ","title":"Where can I get help?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Please open a Github issue! This is a new package and we would love to hear your suggestions, bug reports, feature requests, and other commentary.","category":"page"},{"location":"faq/#Isn't-this-functionality-included-in-JuMP?","page":"FAQ","title":"Isn't this functionality included in JuMP?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"JuMP provides support for integer and Boolean-valued variables, however it is developed primarily to support mathematical optimization over real-valued or integer-valued variables and continuous functions. As such, JuMP interfaces with solvers such as ECOS, MOSEK, and Gurobi that are intended for continuous optimization problems. When you use JuMP to solve a problem with discrete variables, your solver will likely use a branch-and-bound style method.","category":"page"},{"location":"faq/#Should-I-use-JuMP-or-Satisfiability.jl?","page":"FAQ","title":"Should I use JuMP or Satisfiability.jl?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"If you have a problem with mostly real variables and a few discrete integer or Boolean variables, you should probably use JuMP to call a branch-and-bound solver.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"If you have a problem with only discrete variables, especially a large one, you should consider using an SMT solver. SMT can also represent specific variable types, like BitVectors, that JuMP cannot.","category":"page"},{"location":"faq/#How-do-I-solve-SMT-problems-in-other-langugages?","page":"FAQ","title":"How do I solve SMT problems in other langugages?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"In Python, you can use PySMT to access a wide variety of solvers.\nSimilarly, Java has JavaSMT.\nSolver-specific APIs include CVC5 APIs for C++, Java, and Python.\nZ3 has APIs for C, C++, .NET, Java, Python, and ML/OCaml. Additionally, Microsoft Research provides tutorials for using Z3 in Python and JavaScript.\nOther solvers include PicoSAT, YICES, MathSAT and Boolector.","category":"page"},{"location":"faq/#Are-there-other-SMT-libraries-in-Julia?","page":"FAQ","title":"Are there other SMT libraries in Julia?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"There are Julia bindings for the Z3 C++ API.\nPicoSAT also has Julia bindings. You'll need to understand CNF format to use these.\nHere is a package for modelling discrete constraint satisfaction problems and encoding them to Boolean satisfiability (SAT) problems. ","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"To our knowledge, Satisfiability.jl is the first general-purpose SMT library in Julia.","category":"page"},{"location":"faq/#What-about-other-theories-in-the-SMT-standard?","page":"FAQ","title":"What about other theories in the SMT standard?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"In the future support may be added for additional theories supported in the SMTLIB2 standard, such as bitvectors and arrays.","category":"page"},{"location":"faq/#How-can-I-retrieve-a-proof-or-unsat-core-from-the-solver?","page":"FAQ","title":"How can I retrieve a proof or unsat core from the solver?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Unsatisfiability proofs are difficult to support because the SMT2 standard doesn't specify their format - it's solver-dependent. Although we don't provide an explicit function, you can still retrieve a proof in two ways:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Instead of calling sat!, use save to write the SMT representation of your problem to a file. Then invoke the solver from your command line, feed it the file and issue (get-proof) in unsat mode.\nCall sat! on your problem as shown here, then use send_command to issue (get-proof).","category":"page"},{"location":"faq/#What-does-Satisfiability.jl-actually-do?","page":"FAQ","title":"What does Satisfiability.jl actually do?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"We provide a high-level interface to SMT solvers. SMT solvers can accept input in the SMT2 format, which is very powerful but not easy to read. When you specify an SMT problem in Satisfiability.jl and call sat!, we generate an SMT2-formatted representation of the problem, feed it to a solver, then interpret the result.","category":"page"},{"location":"faq/#LFAQ","page":"FAQ","title":"LFAQ","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"(Less frequently-asked questions.)","category":"page"},{"location":"faq/#Why-is-sat!-so-slow-for-real-valued-variables?","page":"FAQ","title":"Why is sat! so slow for real-valued variables?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Because the SMT theory of real-valued variables is incomplete.","category":"page"},{"location":"example_bad_assertions/#Pushing-and-popping-assertions","page":"Pushing and popping assertions","title":"Pushing and popping assertions","text":"","category":"section"},{"location":"example_bad_assertions/","page":"Pushing and popping assertions","title":"Pushing and popping assertions","text":"In this problem we have some expressions we need to satisfy, and some that we would like to satisfy (but we can't satisfy them all). We want to figure out which expressions we can satisfy using push() and pop() to assert and remove them as necessary.","category":"page"},{"location":"example_bad_assertions/","page":"Pushing and popping assertions","title":"Pushing and popping assertions","text":"using Satisfiability\n@satvariable(x, Bool)\n@satvariable(y, Bool)\n@satvariable(z, Bool)\nnecessary_exprs = or(and(not(x), y, z), and(not(y), x, z))\n\ninteractive_solver = open(CVC5())","category":"page"},{"location":"example_bad_assertions/","page":"Pushing and popping assertions","title":"Pushing and popping assertions","text":"We assert this at the first level, since we always have to have it.","category":"page"},{"location":"example_bad_assertions/","page":"Pushing and popping assertions","title":"Pushing and popping assertions","text":"assert!(interactive_solver, necessary_exprs)","category":"page"},{"location":"example_bad_assertions/","page":"Pushing and popping assertions","title":"Pushing and popping assertions","text":"Here are some conflicting expressions. One of them is satisfiable when necessary_exprs is true; the others are not.","category":"page"},{"location":"example_bad_assertions/","page":"Pushing and popping assertions","title":"Pushing and popping assertions","text":"conflicting_exprs = [\n    not(z),\n    and(not(x), not(y)),\n    not(x),\n    and(x,y),\n]","category":"page"},{"location":"example_bad_assertions/","page":"Pushing and popping assertions","title":"Pushing and popping assertions","text":"We'll use push and pop to add and remove them one at a time.","category":"page"},{"location":"example_bad_assertions/","page":"Pushing and popping assertions","title":"Pushing and popping assertions","text":"for e in conflicting_exprs\n    # Push one assertion level on the stack\n    push!(interactive_solver)\n\n    # Now assert an expression that might make the problem unsatisfiable\n    assert!(interactive_solver, e)\n    # Note: logic here is NONE meaning only propositional logic. This arises because we used Yices, which requires setting the logic.\n    status, assignment = sat!(interactive_solver, logic=\"NONE\")\n\n    if status == :SAT\n        println(\"We found it! Expr \\n$e \\nis satisfiable.\")\n        assign!(necessary_exprs, assignment)\n        assign!(conflicting_exprs, assignment)\n    else\n        # Pop one level off the stack, removing the problematic assertion.\n        pop!(interactive_solver)\n    end\nend","category":"page"},{"location":"example_bad_assertions/#Another-way-to-do-this.","page":"Pushing and popping assertions","title":"Another way to do this.","text":"","category":"section"},{"location":"example_bad_assertions/","page":"Pushing and popping assertions","title":"Pushing and popping assertions","text":"Let's reset the solver so we can try another way to do the same thing. This command clears all assertions, including the first one we made at level 1.","category":"page"},{"location":"example_bad_assertions/","page":"Pushing and popping assertions","title":"Pushing and popping assertions","text":"reset_assertions!(interactive_solver)","category":"page"},{"location":"example_bad_assertions/","page":"Pushing and popping assertions","title":"Pushing and popping assertions","text":"This time, we use sat!(solver, exprs...) which is equivalent to the SMT-LIB command (check-sat-assuming exprs...). Thus the expression is not asserted but is assumed within the scope of the sat! call.","category":"page"},{"location":"example_bad_assertions/","page":"Pushing and popping assertions","title":"Pushing and popping assertions","text":"assert!(interactive_solver, necessary_exprs)\n# Here's an equivalent way to do this by passing exprs into sat!. This is equivalent to the SMT-LIB syntax \"(check-sat-assuming (exprs...))\", which does not (assert) the expressions but assumes they should be satisfied.\nfor e in conflicting_exprs\n    status, assignment = sat!(interactive_solver, e)\n    println(\"status = $status\")\n    if status == :SAT\n        println(\"We found it! Expr \\n$e \\nis satisfiable.\")\n        assign!(necessary_exprs, assignment)\n        assign!(conflicting_exprs, assignment)\n    end\nend\n\n# We're done, so don't forget to clean up.\nclose(interactive_solver)","category":"page"},{"location":"#Solving-SMT-Problems-in-Julia","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"","category":"section"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"Satisfiability.jl is a package for representing Boolean satisfiability (SAT) and selected other satisfiability modulo theories (SMT) problems in Julia. This package provides a simple front-end interface to common SMT solvers, including full support for vector-valued and matrix-valued expressions.","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"Pages = [\"index.md\"]\nDepth = 4","category":"page"},{"location":"#What-is-a-SAT-problem?","page":"Solving SMT Problems in Julia","title":"What is a SAT problem?","text":"","category":"section"},{"location":"#Boolean-variables-and-literals","page":"Solving SMT Problems in Julia","title":"Boolean variables and literals","text":"","category":"section"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"A Boolean variable can only take on the values true or false (0 or 1).","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"The variable z, which could be either true or false, is a variable, while the value true is a literal. Julia provides built-in support for Boolean literals using the Bool type. This package defines the BoolExpr type to represent Boolean variables.","category":"page"},{"location":"#Logical-formulae","page":"Solving SMT Problems in Julia","title":"Logical formulae","text":"","category":"section"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"We can construct a logical formula using Boolean variables, literals, and operators. This package defines four operators. Both the plaintext and mathematical symbols are available.","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"not(z), or ¬z: the negation of z.\nand(z1, z2) or z1 ∧ z2. The n-ary version, and(z1,...,zn), is also available.\nand(z1, z2) or z1 ∨ z2. The n-ary version, and(z1,...,zn), is also available.\nimplies(z1, z2) or z1 ⟹ z2.","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"These expressions can be nested to produce formulae of arbitrary complexity.","category":"page"},{"location":"#SAT-problems","page":"Solving SMT Problems in Julia","title":"SAT problems","text":"","category":"section"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"Given a Boolean expression, the associated SAT problem can be posed as:","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"\"Is there a satisfying assignment of literals (1's and 0's) such that this formula is true?\"","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"If this assignment exists, we say the formula is satisfiable. More than one satisfying assignment may exist for a given formula.\nIf the assignment does not exist, we say the formula is unsatisfiable.","category":"page"},{"location":"#SMT-problems","page":"Solving SMT Problems in Julia","title":"SMT problems","text":"","category":"section"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"Satisfiability modulo theories is a superset of Boolean satisfiability. SMT encompasses many other theories besides Boolean logic, several of which are supported here.","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"In the theory of integers, we can define integer-valued variables and operations such as +, -, * and the comparisons <, <=, ==, =>, >. For example, we could determine whether there exists a satisfying assignment for integers a and b such that a <= b, b <= 1 and a + b >= 2. (There is - set a = 1 and b = 1.)","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"In the theory of reals, we can define real-valued variables and operations. Reals use the same operations as integers, plus division (\\). However, algorithms to solve SMT problems over real variables are often slow and not guaranteed to find a solution. If you have a problem over only real-valued variables, you should use JuMP and a solver like Gurobi instead.","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"In the theory of fixed-length BitVectors one can prove properties over BitVectors, which are useful for representing fixed-size integer arithmetic. For example, you can use formal verification to prove correctness of your code - or discover bugs (some examples here), like the sneaky Binary Search bug that went undetected for 20 years.","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"SMT extends to other theories including IEEE floating-point numbers, arrays and strings. While this package is still under development, we plan to implement support for the SMT-LIB standard theories and operations.","category":"page"},{"location":"#How-does-Satisfiability.jl-work?","page":"Solving SMT Problems in Julia","title":"How does Satisfiability.jl work?","text":"","category":"section"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"Satisfiability.jl provides an interface to SAT solvers that accept input in the SMTLIB2 format. It works by generating the SMT representation of your problem, then invoking a solver to read said file.","category":"page"},{"location":"","page":"Solving SMT Problems in Julia","title":"Solving SMT Problems in Julia","text":"Using this package, you should be able to interact with any solver that implements the SMT-LIB standard. We currently test with Z3 and CVC5.","category":"page"},{"location":"example_uninterpreted_func/#Uninterpreted-Functions","page":"Uninterpreted Functions","title":"Uninterpreted Functions","text":"","category":"section"},{"location":"example_uninterpreted_func/","page":"Uninterpreted Functions","title":"Uninterpreted Functions","text":"An uninterpreted function is a function where the mapping between input and output is not known. The task of the SMT solver is then to determine a mapping such that some SMT expression holds true.","category":"page"},{"location":"example_uninterpreted_func/","page":"Uninterpreted Functions","title":"Uninterpreted Functions","text":"Satisfiability.jl represents uninterpreted functions as callable structs. This enables the simple syntax:","category":"page"},{"location":"example_uninterpreted_func/","page":"Uninterpreted Functions","title":"Uninterpreted Functions","text":"@uninterpreted(myfunc, Int, Int)\n\n# we can call myfunc on an Int constant or variable\n@satvariable(a, Int)\nmyfunc(a)\nmyfunc(-2) # returns \n\n# we cannot call myfunc on the wrong type\n# myfunc(true) yields an error\n# myfunc(1.5) yields an error","category":"page"},{"location":"example_uninterpreted_func/","page":"Uninterpreted Functions","title":"Uninterpreted Functions","text":"As a small example, we can ask whether there exists a function f(x) such that f(f(x)) == x, f(x) == y and x != y.","category":"page"},{"location":"example_uninterpreted_func/","page":"Uninterpreted Functions","title":"Uninterpreted Functions","text":"Note that when using Yices, you must set the logic. Here we set it to \"QF_UFLIA\" - \"Quantifier free uninterpreted functions, linear integer arithmetic\". (This is OK even though we're only using Boolean variables. We have to include uninterpreted functions or Yices will hang.)","category":"page"},{"location":"example_uninterpreted_func/","page":"Uninterpreted Functions","title":"Uninterpreted Functions","text":"@satvariable(x, Bool)\n@satvariable(y, Bool)\n@uninterpreted(f, Bool, Bool)\n\nstatus = sat!(distinct(x,y), f(x) == y, f(f(x)) == x, solver=Yices(), logic=\"QF_UFLIA\")\nprintln(\"status = \\$status\")","category":"page"},{"location":"example_uninterpreted_func/","page":"Uninterpreted Functions","title":"Uninterpreted Functions","text":"It turns out there is. Since the satisfying assignment for an uninterpreted function is itself a function, Satisfiability.jl represents this by setting the value of f to this function. Now calling f(value) will return the value of this satisfying assignment.","category":"page"},{"location":"example_uninterpreted_func/","page":"Uninterpreted Functions","title":"Uninterpreted Functions","text":"println(f(x.value)) # prints 0\nprintln(f(x.value) == y.value) # true\nprintln(f(f(x.value)) == x.value) # true","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here we present several mini-examples of SMT problems.","category":"page"},{"location":"tutorial/#Proving-the-validity-of-De-Morgan's-law","page":"Tutorial","title":"Proving the validity of De Morgan's law","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This example is borrowed from Microsoft's introduction to Z3 for propositional logic.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We say a formula is valid if it is true for every assignment of values to its variables. For example, z ∨ ¬z is valid. (This is useful because a valid formula can provide a useful transformation or simplification of a logical expression.)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"One famous transformation is De Morgan's law: a ∧ b = ¬(¬a ∨ ¬b). To show validity of De Morgan's law, we can construct the bidirectional implication a ∧ b ⟺ ¬(¬a ∨ ¬b). It suffices to show that the negation of this formula is unsatisfiable.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@satvariable(a, Bool)\n@satvariable(b, Bool)\n\nconjecture = iff(a ∧ b, ¬(¬a ∨ ¬b))\nstatus = sat!(¬conjecture, solver=Z3()) # status will be either :SAT or :UNSAT","category":"page"},{"location":"tutorial/#A-common-logical-mistake","page":"Tutorial","title":"A common logical mistake","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Suppose you have Boolean variables p, q and r. A common mistake made by students in discrete math classes is to think that if p implies q and q implies r ((p ⟹ q) ∧ (q ⟹ r)) then p must imply r (p ⟹ r). Are these statements equivalent? We can use a SAT solver to check.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@satvariable(p, Bool)\n@satvariable(q, Bool)\n@satvariable(r, Bool)\n\nconjecture = iff((p ⟹ q) ∧ (q ⟹ r), p ⟹ r)\nstatus = sat!(¬conjecture, solver=Z3())","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Unlike the previous example the status is :SAT, indicating there is an assignment p, q and r that disproves the conjecture.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"println(\"p = $(value(p))\")\nprintln(\"q = $(value(q))\")\nprintln(\"r = $(value(r))\")","category":"page"},{"location":"tutorial/#Optimizing-over-integers","page":"Tutorial","title":"Optimizing over integers","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The knapsack problem is a famous NP-complete problem in which you are packing a bag that cannot exceed some maximum weight. Given a set of items with known value and weight, you want to pack a subset that maximizes the value.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A simpler version, illustrated in this classic XKCD strip, is to pack the bag to exactly its maximum weight (or spend a specific amount of money). In fact, the problem in the XKCD strip can be expressed as a linear equation over integers.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@satvariable(a[1:6], Bool)\nc = [215; 275; 335; 355; 420; 580]\nexpr = and(and(a .>= 0), sum(a .* c) == 1505)\nsat!(expr, solver=Z3())\nprintln(\"Result: $(value(a))\")\nprintln(\"Check: $(sum(value(a) .* c))\")","category":"page"},{"location":"tutorial/#Proving-properties-of-fixed-size-integer-arithmetic","page":"Tutorial","title":"Proving properties of fixed-size integer arithmetic","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This example is from Microsoft's Z3 tutorial. A bitvector x is a power of two (or zero) if and only if x & (x - 1) is zero, where & is bitwise and. We prove this property for an 8-bit vector.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"println(\"Example 1 (should be SAT)\")\n@satvariable(b, BitVector, 8)\nis_power_of_two = b & (b - 0x01) == 0\n\n# iff is_power_of_two holds, b must be one of 1, 2, 4, ... 128\nexpr = iff(is_power_of_two,\n           or(b == 2^i for i=0:7))\nstatus = sat!(expr, solver=Z3())\n#println(smt(expr))\nprintln(status) # if status is SAT we proved it.","category":"page"}]
}
